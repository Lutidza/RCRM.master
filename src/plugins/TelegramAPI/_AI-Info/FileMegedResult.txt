–¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è —Ñ–∞–π–ª–æ–≤, –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–µ–º—Å—è –¥–∞–ª—å—à–µ –æ—Ç –Ω–µ—ë. –î–æ—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ—ë. 

-------------------------



-------------------------

// Path: src/plugins/TelegramAPI/index.TelegramAPI.ts
// Version: 5.7.1-refactored
// –ü–æ–¥—Ä–æ–±–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ –∫–æ–¥–µ:
// - –≠—Ç–æ—Ç —Ñ–∞–π–ª –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–ª–∞–≥–∏–Ω–∞ TelegramAPI –∫ Payload CMS.
// - –†–∞–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∞—Å—å —Ñ—É–Ω–∫—Ü–∏—è initializeBots –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–æ–≤,
//   —Ç–µ–ø–µ—Ä—å –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è registerBots –∏–∑ —Ñ–∞–π–ª–∞ registerBots.ts.

import type { Payload, Config, Plugin } from 'payload';
import Bots from '@/collections/TelegramAPI/Bots';
import Clients from '@/collections/TelegramAPI/Clients';
import { registerBots } from '@/plugins/TelegramAPI/utils/BotUtils/registerBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const TelegramAPIPlugin: Plugin = (incomingConfig: Config): Config => {
  return {
    ...incomingConfig,
    collections: [
      ...(incomingConfig.collections || []),
      Bots,
      Clients,
    ],
    onInit: async (payload: Payload) => {
      log('info', 'TelegramAPIPlugin initialization started.', payload);
      await registerBots(payload);
      log('info', 'TelegramAPIPlugin registered successfully.', payload);
    },
  };
};

export default TelegramAPIPlugin;
// Path: src/plugins/TelegramAPI/utils/ClientUtils/processClient.ts
// Version: 1.3.9-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –£–¥–∞–ª–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ FromData, –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ TelegramBlocksTypes.ts.
// –ü–æ–ª—è telegramId –∏ botId –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è —á–∞—Å—Ç—å—é –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª—è Telegram.

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–∞ FromData –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ —Å —Ç–∏–ø–∞–º–∏
import type { FromData } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function processClient(
  payload: Payload,
  telegramId: number,
  botId: number,
  fromData: FromData
): Promise<any> {
  try {
    log('info', `[processClient] Searching for client with telegram_id=${telegramId} and bot=${botId}`, payload);

    const { docs } = await payload.find({
      collection: 'clients',
      where: { telegram_id: { equals: telegramId } },
      limit: 1,
    });

    let client: any;

    if (!docs || docs.length === 0) {
      log('info', "[processClient] No existing client found, creating a new one...", payload);
      client = await payload.create({
        collection: 'clients',
        data: {
          telegram_id: telegramId,                   // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram
          bots: [botId],                             // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±–æ—Ç–∞
          first_name: fromData.first_name ?? "",
          last_name: fromData.last_name ?? "",
          user_name: fromData.username || 'anonymous_user',
          total_visit: 1,                            // –ü–µ—Ä–≤–æ–µ –ø–æ—Å–µ—â–µ–Ω–∏–µ
          last_visit: new Date().toISOString(),      // –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –∫–∞–∫ –¥–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–∏–∑–∏—Ç–∞
          enabled: "enabled"
          // –ü–æ–ª–µ status –Ω–µ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è, —á—Ç–æ–±—ã –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å —á–µ—Ä–µ–∑ defaultValue –∏–ª–∏ beforeChange-—Ö—É–∫ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏.
        },
      });
    } else {
      const existingClient = docs[0]!;
      log('info', `[processClient] Client found: ID=${existingClient.id}`, payload);
      let botsArray: any[] = Array.isArray(existingClient.bots)
        ? existingClient.bots
        : existingClient.bots ? [existingClient.bots] : [];
      if (!botsArray.some(b =>
        b != null && typeof b === 'object'
          ? b.id !== undefined && b.id.toString() === botId.toString()
          : b != null && b.toString() === botId.toString()
      )) {
        botsArray.push(botId);
        log('info', `[processClient] Bot ${botId} added to client ${existingClient.id}`, payload);
      }
      client = await payload.update({
        collection: 'clients',
        id: existingClient.id,
        data: {
          bots: botsArray,
          first_name: fromData.first_name ?? existingClient.first_name ?? "",
          last_name: fromData.last_name ?? existingClient.last_name ?? "",
          user_name: fromData.username || existingClient.user_name || 'anonymous_user',
          last_visit: new Date().toISOString(),
          total_visit: (existingClient.total_visit ?? 0) + 1,
        },
      });
    }

    log('debug', `[processClient] Client status: ${client.status}`, payload);
    const statusAlias = await checkClientStatus(payload, client.status);
    log('debug', `[processClient] Retrieved status alias: ${statusAlias}`, payload);
    const isBanned = statusAlias === 'banned';

    if (isBanned) {
      log('info', `[processClient] Client ID=${client.id} is banned. Updating status...`, payload);
      client = await payload.update({
        collection: 'clients',
        id: client.id,
        data: {
          enabled: "disabled",
        },
      });
      client.isBanned = true;
    } else {
      client.isBanned = false;
    }

    return client;
  } catch (error: any) {
    log('error', `[processClient] Error processing client: ${error.message}`, payload);
    return { total_visit: 1 };
  }
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/checkClientStatus.ts
// Version: 1.1.5-stable
//
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —á–∏—Å–ª–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–æ–ª–µ status.
// - –ï—Å–ª–∏ status —Ä–∞–≤–µ–Ω undefined –∏–ª–∏ null, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è "new" –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
// - –ï—Å–ª–∏ status ‚Äì –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º alias, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è alias; –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å ‚Äì —á–∏—Å–ª–æ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∑–∞–ø—Ä–æ—Å –∫ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "statuses".
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function checkClientStatus(
  payload: Payload,
  status: any
): Promise<string | null> {
  try {
    if (status === undefined || status === null) {
      log('debug', 'checkClientStatus: status is undefined or null, defaulting to "new"');
      return "new";
    }
    if (typeof status === 'object') {
      if ('alias' in status && typeof status.alias === 'string') {
        return status.alias;
      }
      if ('id' in status) {
        const statusResult = await payload.find({
          collection: 'statuses',
          where: { id: { equals: status.id } },
          limit: 1,
        });
        const statusDoc = statusResult.docs[0];
        return statusDoc?.alias || "new";
      }
    }
    if (typeof status === 'number' || typeof status === 'string') {
      const statusResult = await payload.find({
        collection: 'statuses',
        where: { id: { equals: status } },
        limit: 1,
      });
      const statusDoc = statusResult.docs[0];
      return statusDoc?.alias || "new";
    }
  } catch (error: any) {
    log('error', `‚ùå –û—à–∏–±–∫–∞ –≤ checkClientStatus: ${error.message}`, payload);
  }
  return "new";
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/bannedClient.ts
// Version: 1.2.3-stable
//
// [CHANGELOG]
// - –û–±—ä–µ–¥–∏–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–Ω–∞ –≤ –æ–¥–∏–Ω middleware.
// - –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Å–µ—Å—Å–∏–æ–Ω–Ω—ã–π —Ñ–ª–∞–≥ isBanned; –µ—Å–ª–∏ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –¥–∞–ª—å–Ω–µ–π—à–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è.
// - –ï—Å–ª–∏ —Ñ–ª–∞–≥ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ checkClientStatus.
// - –ï—Å–ª–∏ alias —Ä–∞–≤–µ–Ω "banned", –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Ñ–ª–∞–≥ isBanned —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ —Å–µ—Å—Å–∏–∏.
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Context } from 'grammy';
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

export function bannedClientHook(payload: Payload) {
  return async (ctx: Context & { session: any }, next: () => Promise<void>): Promise<void> => {
    try {
      if (ctx.session.isBanned) {
        await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
        log('info', 'bannedClientHook: Session indicates client is banned, skipping processing.', payload);
        return;
      }
      if (ctx.from) {
        const telegramId = ctx.from.id;
        const { docs } = await payload.find({
          collection: 'clients',
          where: { telegram_id: { equals: telegramId } },
          limit: 1,
        });
        const client = docs.length > 0 ? docs[0] : null;
        if (client && client.status) {
          const statusAlias = await checkClientStatus(payload, client.status);
          if (statusAlias === 'banned') {
            await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
            log('info', `bannedClientHook: Client ID=${client.id} is banned according to DB check.`, payload);
            ctx.session.isBanned = true;
            return;
          }
        }
      }
      await next();
    } catch (error: any) {
      log('error', `bannedClientHook: Error checking ban status: ${error.message}`, payload);
      await next();
    }
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock.ts
// Version: 1.3.9-no-manual-protect
// [CHANGELOG]
// - –£–±—Ä–∞–Ω–æ —Ä—É—á–Ω–æ–µ protect_content. rely on monkey-patch in setupMiddlewares.

import type { Payload } from 'payload';
import type { BotContext, TelegramLayoutBlock } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
import { handleButtonBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const blockHandlers: Record<string, (ctx: BotContext, block: any, payload: Payload) => Promise<void>> = {
  messageblock: processMessageBlock,
  'message-blocks': processMessageBlock,
  buttonblock: async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  'button-blocks': async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  catalogblock: renderCatalogBlock,
  'catalog-blocks': renderCatalogBlock,
};

export async function sendLayoutBlock(
  ctx: BotContext,
  botConfig: any,
  payload: Payload,
  aliasOverride?: string
): Promise<void> {
  const layoutAlias = aliasOverride ?? botConfig.interface?.defaultStartLayout;
  if (!layoutAlias) {
    await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
    return;
  }

  try {
    log('debug', `–ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π layoutAlias: ${layoutAlias}`);
    if (ctx.session.currentState && ctx.session.currentState.alias !== layoutAlias) {
      ctx.session.stateStack.push(ctx.session.currentState);
    }

    if (!botConfig.interface || !botConfig.interface.blocks || botConfig.interface.blocks.length === 0) {
      await ctx.reply(`Layout "${layoutAlias}" –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –±–ª–æ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      return;
    }

    const layoutBlock: TelegramLayoutBlock | undefined = botConfig.interface.blocks.find(
      (block: any) => block.alias === layoutAlias
    );
    if (!layoutBlock) {
      const msg = await ctx.reply(`Layout "${layoutAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    ctx.session.currentState = layoutBlock;

    if (layoutBlock.clearPreviousMessages && ctx.chat) {
      log('debug', `–û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–µ—Ä–µ–¥ LayoutBlock "${layoutBlock.name}"`);
      await clearPreviousMessages(ctx);
    }

    if (!Array.isArray(layoutBlock.blocks) || layoutBlock.blocks.length === 0) {
      const msg = await ctx.reply(`Layout "${layoutBlock.name}" –ø—É—Å—Ç. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    for (const block of layoutBlock.blocks) {
      try {
        const blockType = block.blockType?.toLowerCase();
        const handler = blockHandlers[blockType];
        if (handler) {
          log('debug', `–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–ª–æ–∫ —Ç–∏–ø–∞ "${blockType}"`);
          await handler(ctx, block, payload);
        } else {
          log('error', `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${blockType}`, payload);
          const msg = await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${block.blockType}`);
          storeMessageId(ctx, msg.message_id);
        }
      } catch (blockError) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–∞: ${(blockError as Error).message}`, payload);
        const msg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–ª–æ–∫–∞: ${layoutBlock.name}`);
        storeMessageId(ctx, msg.message_id);
      }
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞ "${layoutAlias}": ${(error as Error).message}`, payload);
    const errorMsg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞: "${layoutAlias}"`);
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductDetails.ts
// Version: 1.0.0
// [CHANGELOG]
// - –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç–æ—á–∫—É (–ø–æ–ª–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –≥–∞–ª–µ—Ä–µ—è —Ñ–æ—Ç–æ, –∏ —Ç. –¥.)
// - –ö–Ω–æ–ø–∫–∏: ¬´–í –∫–æ—Ä–∑–∏–Ω—É¬ª, ¬´–ù–∞–∑–∞–¥¬ª, ¬´–ó–∞–∫–∞–∑–∞—Ç—å¬ª (–ø—Ä–∏–º–µ—Ä–Ω–æ)

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderProductDetails(
  ctx: BotContext,
  productId: string | number,
  payload: Payload
): Promise<number | null> {
  try {
    if (!ctx.chat) {
      log('error', 'renderProductDetails: –ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return null;
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const notFoundMsg = await ctx.reply("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.");
      storeMessageId(ctx, notFoundMsg.message_id);
      return notFoundMsg.message_id;
    }

    // –ü—Ä–∏–º–µ—Ä: –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –≤—Å—ë –Ω—É–∂–Ω–æ–µ
    const { name, price, size, status, images, description } = product as any;
    const statusAlias = (status?.alias) ? status.alias : 'N/A';

    // HTML –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏
    let detailsText = `<b>${name}</b>\n`;
    detailsText += `<b>–¶–µ–Ω–∞:</b> ${price}$\n`;
    detailsText += `<b>–†–∞–∑–º–µ—Ä:</b> ${size}\n`;
    detailsText += `<b>–°—Ç–∞—Ç—É—Å:</b> ${statusAlias}\n\n`;
    detailsText += `<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n${description || '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è'}\n\n`;
    detailsText += `–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`;

    // –ö–Ω–æ–ø–∫–∏ (–ø—Ä–∏–º–µ—Ä)
    const keyboard = new InlineKeyboard()
      .text("–í –∫–æ—Ä–∑–∏–Ω—É", `addToCart|${product.id}`)
      .text("–ù–∞–∑–∞–¥", `catalogBackPage|...`)  // –∏–ª–∏ "layout|store_home_page", –∫–∞–∫ –≤–∞–º —É–¥–æ–±–Ω–µ–µ
      .row()
      .text("–ó–∞–∫–∞–∑–∞—Ç—å", `order|${product.id}`);

    // –ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ (–µ—Å–ª–∏ images.length>1) —á–µ—Ä–µ–∑ replyWithMediaGroup,
    // –Ω–æ –≤ –ø—Ä–æ—Å—Ç–æ–º —Å–ª—É—á–∞–µ ‚Äî –æ–¥–Ω–æ "–≥–ª–∞–≤–Ω–æ–µ" —Ñ–æ—Ç–æ:
    const mainPhotoUrl = (Array.isArray(images) && images.length > 0)
      ? images[0].url
      : 'https://kvartiry-tbilisi.ru/images/demo/product_banner.png';

    const msg = await ctx.replyWithPhoto(mainPhotoUrl, {
      caption: detailsText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
    storeMessageId(ctx, msg.message_id);

    log('info', `renderProductDetails: –¢–æ–≤–∞—Ä ID ${product.id} (–¥–µ—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.`, payload);
    return msg.message_id;
  } catch (error: any) {
    log('error', `renderProductDetails: –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–≤–æ–¥–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏: ${error.message}`, payload);
    const errMsg = await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–≤–∞—Ä–µ.");
    storeMessageId(ctx, errMsg.message_id);
    return null;
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryNav.ts
// Version: 1.2.0-add-store-button
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "üõí Store" –º–µ–∂–¥—É Back –∏ Next.
// - –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (page == totalPages), –≤–º–µ—Å—Ç–æ Next –≤—ã–≤–æ–¥–∏–º Home (layout|home_page).

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

async function clearPageMessages(ctx: BotContext): Promise<void> {
  if (!ctx.session.categoryPageMessages || !ctx.session.categoryPageMessages.length) return;
  if (!ctx.chat?.id) return;

  for (const msgId of ctx.session.categoryPageMessages) {
    try {
      await ctx.api.deleteMessage(ctx.chat.id, msgId);
    } catch (err) {
      // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
    }
  }
  ctx.session.categoryPageMessages = [];
}

export async function renderCategoryNav(
  ctx: BotContext,
  payload: Payload,
  rawCategoryId: string,
  page: number,
  itemsPerPage: number,
  direction: 'next' | 'back'
): Promise<void> {
  try {
    // –£–¥–∞–ª—è–µ–º —Ç–æ–≤–∞—Ä—ã/–ø–∞–Ω–µ–ª—å –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    await clearPageMessages(ctx);

    const categoryId = parseInt(rawCategoryId, 10);
    const pagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = pagination.docs;
    const totalPages = pagination.totalPages;

    if (!products || products.length === 0) {
      const noMoreMsg = await ctx.reply("–ù–µ—Ç –±–æ–ª—å—à–µ —Ç–æ–≤–∞—Ä–æ–≤.");
      storeMessageId(ctx, noMoreMsg.message_id);
      return;
    }

    if (!ctx.session.categoryPageMessages) {
      ctx.session.categoryPageMessages = [];
    }

    // –†–µ–Ω–¥–µ—Ä–∏–º —Ç–æ–≤–∞—Ä—ã
    for (const product of products) {
      const productMsgId = await renderProductCard(ctx, product.id, payload);
      if (productMsgId) {
        ctx.session.categoryPageMessages.push(productMsgId);
      }
    }

    // –ö–Ω–æ–ø–∫–∏
    const navKeyboard = new InlineKeyboard();

    // 1) Back
    //   - –ï—Å–ª–∏ page=1 => –æ–±—ã—á–Ω–æ Back => layout|store_home_page (–∏–ª–∏ —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤–∞—à–µ–≥–æ –∫–æ–¥–∞)
    //   - –ò–Ω–∞—á–µ => catalogBackPage|...
    if (page === 1) {
      navKeyboard.text("Back", "layout|store_home_page");
    } else {
      navKeyboard.text("Back", `catalogBackPage|${categoryId}|${page - 1}|${itemsPerPage}`);
    }

    // 2) üõí Store (–º–µ–∂–¥—É Back –∏ Next/Home)
    navKeyboard.text("üõí Store", "layout|store_home_page");

    // 3) Next / Home
    if (page < totalPages) {
      navKeyboard.text("Next", `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`);
    } else {
      // –ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ => Home
      navKeyboard.text("Home", "layout|home_page");
    }

    const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞: ${page} –∏–∑ ${totalPages}`, {
      parse_mode: 'HTML',
      reply_markup: navKeyboard,
    });
    storeMessageId(ctx, navMsg.message_id);
    ctx.session.categoryPageMessages.push(navMsg.message_id);

    log('info', `renderCategoryNav: page=${page}, direction=${direction}, catId=${categoryId}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ renderCategoryNav: ${error.message}`, payload);
    const errMsg = await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥—Ä—É–∑–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.");
    storeMessageId(ctx, errMsg.message_id);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/index.TelegramAPI.ts
// üìå –í–µ—Ä—Å–∏—è: 1.2.0
//
// [CHANGELOG]
// - –£–±—Ä–∞–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Ç–æ–≤–∞—Ä—ã –Ω–∞ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ `CatalogBlock`.
// - –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤—ã–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

/**
 * –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ `CatalogBlock`.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} block - –ë–ª–æ–∫ –∫–∞—Ç–∞–ª–æ–≥–∞.
 * @param {Payload} payload - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS.
 */
export async function renderCatalogBlock(ctx: BotContext, block: any, payload: Payload): Promise<void> {
  try {
    if (!block || !ctx.chat) {
      throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–ª–æ–∫ –∏–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞.');
    }

    const inlineKeyboard = new InlineKeyboard();

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } }, // –¢–æ–ª—å–∫–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
      limit: 999,
    });

    const categories = categoriesResult.docs;

    // –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç
    if (categories.length === 0) {
      await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row(); // –ù–æ–≤—ã–π —Ä—è–¥ –∫–∞–∂–¥—ã–µ 2 –∫–Ω–æ–ø–∫–∏
    });

    // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–±–ª–æ–∂–∫–æ–π –∏ –æ–ø–∏—Å–∞–Ω–∏–µ–º
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';

    await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });

    log('info', `–ö–∞—Ç–∞–ª–æ–≥ —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂—ë–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/paginateCategoryItems.ts
// Version: 1.1.2
//
// [CHANGELOG]
// - –§—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª—è–º–∏ docs –∏ totalPages –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–∞–Ω–∏—Ü.
import type { Payload, CollectionSlug } from 'payload';

export async function paginateCategoryItems(
  payload: Payload,
  collection: CollectionSlug,
  where: Record<string, any>,
  page: number,
  itemsPerPage: number,
): Promise<{ docs: any[]; totalPages: number }> {
  try {
    const result = await payload.find({
      collection,
      where,
      limit: itemsPerPage,
      page,
      sort: 'name',
    });
    return {
      docs: result.docs || [],
      totalPages: result.totalPages || Math.ceil((result.totalDocs || 0) / itemsPerPage),
    };
  } catch (error: any) {
    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}":`, error);
    throw new Error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}".`);
  }
}

export function generatePaginationData(
  currentPage: number,
  totalItems: number,
  itemsPerPage: number,
): {
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
} {
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  return {
    currentPage,
    totalPages,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock.ts
// Version: 1.4.3-no-manual-protect
// [CHANGELOG]
// - –£–¥–∞–ª–µ–Ω–æ manual protect_content, rely on middleware monkey-patch.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderCatalogBlock(
  ctx: BotContext,
  block: any,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }

    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } },
      limit: 999,
    });
    const categories = categoriesResult.docs;
    if (categories.length === 0) {
      const emptyMsg = await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      storeMessageId(ctx, emptyMsg.message_id);
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }

    const inlineKeyboard = new InlineKeyboard();
    const itemsPerPage = block?.itemsPerPage ?? 3;
    categories.forEach((cat: any, idx: number) => {
      inlineKeyboard.text(cat.name, `catalogCategory|${cat.id}|${itemsPerPage}`);
      if ((idx + 1) % 2 === 0) inlineKeyboard.row();
    });

    const bannerUrl = block?.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block?.description || '–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ç–∞–ª–æ–≥–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';

    const catalogMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });
    storeMessageId(ctx, catalogMsg.message_id);

    log('info', `–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ CatalogBlock —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    const errMsg = await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
    storeMessageId(ctx, errMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductSnippet.ts
// Version: 1.0.0
// [CHANGELOG]
// - –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫—É—é –∫–∞—Ä—Ç–æ—á–∫—É (—Å–Ω–∏–ø–ø–µ—Ç) —Ç–æ–≤–∞—Ä–∞ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å HTML-—Ä–∞–∑–º–µ—Ç–∫–æ–π.
// - –ö–Ω–æ–ø–∫–∏: ¬´–ü–æ–¥—Ä–æ–±–Ω–æ¬ª (productDetails|id), ¬´–ó–∞–∫–∞–∑–∞—Ç—å¬ª (order|id).

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

// –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞, –µ—Å–ª–∏ –Ω–µ—Ç —Ñ–æ—Ç–æ
const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductSnippet(
  ctx: BotContext,
  productId: string | number,
  payload: Payload
): Promise<number | null> {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Ç–∞
    if (!ctx.chat) {
      log('error', 'renderProductSnippet: –ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return null;
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const notFoundMsg = await ctx.reply("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.");
      storeMessageId(ctx, notFoundMsg.message_id);
      return notFoundMsg.message_id;
    }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ–ª—è: name, price, size, status, images...
    const { name, price, size, status, images } = product as any;

    // –°—Ç–∞—Ç—É—Å ‚Äî –±–µ—Ä—ë–º alias –∏–ª–∏ label
    const statusAlias = (status?.alias) ? status.alias : 'N/A';

    // HTML-—Ä–∞–∑–º–µ—Ç–∫–∞ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
    // –ü—Ä–∏–º–µ—Ä: <b>–ù–∞–∑–≤–∞–Ω–∏–µ</b>   <b>100$</b>   <b>–†–∞–∑–º–µ—Ä 40</b>   <b>–°—Ç–∞—Ç—É—Å: active</b>
    // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ—Ä–∞–∑—Ä—ã–≤–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã (&nbsp;) –¥–ª—è –æ—Ç—Å—Ç—É–ø–æ–≤
    const snippetLine =
      `<b>${name}</b> &nbsp;&nbsp; <b>${price}$</b> &nbsp;&nbsp; <b>${size}</b> &nbsp;&nbsp; <i>${statusAlias}</i>`;

    // –ú–æ–∂–Ω–æ –≤–∑—è—Ç—å –ø–µ—Ä–≤—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–∑ images, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
    const photoUrl = (Array.isArray(images) && images.length > 0)
      ? images[0].url
      : DEMO_IMAGE_URL;

    // –ö–Ω–æ–ø–∫–∏
    const keyboard = new InlineKeyboard()
      .text("–ü–æ–¥—Ä–æ–±–Ω–æ", `productDetails|${product.id}`)
      .text("–ó–∞–∫–∞–∑–∞—Ç—å", `order|${product.id}`);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    const snippetMsg = await ctx.replyWithPhoto(photoUrl, {
      caption: snippetLine,
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
    storeMessageId(ctx, snippetMsg.message_id);

    log('info', `renderProductSnippet: –¢–æ–≤–∞—Ä ID ${product.id} (–∫–æ—Ä–æ—Ç–∫–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.`, payload);
    return snippetMsg.message_id;
  } catch (error: any) {
    log('error', `renderProductSnippet: –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–≤–æ–¥–µ —Å–Ω–∏–ø–ø–µ—Ç–∞: ${error.message}`, payload);
    const errMsg = await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–≤–∞—Ä–µ.");
    storeMessageId(ctx, errMsg.message_id);
    return null;
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductCard.ts
// Version: 1.1.0-short-snippet
// [CHANGELOG]
// 1. –í—ã–≤–æ–¥–∏–º –∫–æ—Ä–æ—Ç–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–≤–∞—Ä–µ: –æ–±–ª–æ–∂–∫–∞, name, price, size, status.
// 2. –î–æ–±–∞–≤–ª—è–µ–º –¥–≤–µ –∫–Ω–æ–ø–∫–∏: ¬´–ü–æ–¥—Ä–æ–±–Ω–æ¬ª (productDetails|id) –∏ ¬´–ó–∞–∫–∞–∑–∞—Ç—å¬ª (order|id).
// 3. –£–¥–∞–ª–∏–ª–∏ manual protect_content ‚Äî —É –≤–∞—Å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è ¬´–º–æ–Ω–∫–∏-–ø–∞—Ç—á¬ª –≤ setupMiddlewares.ts.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

// –ú–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –¥–µ–º–æ-URL –∏–ª–∏ –±—Ä–∞—Ç—å —Ä–µ–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–∑ product.images
const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductCard(
  ctx: BotContext,
  productId: string | number,
  payload: Payload
): Promise<number | null> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return null;
    }

    // –ò—â–µ–º —Ç–æ–≤–∞—Ä –ø–æ ID
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      // –ï—Å–ª–∏ —Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
      const msg = await ctx.reply("–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.");
      storeMessageId(ctx, msg.message_id);
      return msg.message_id;
    }

    // –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –Ω—É–∂–Ω—ã–µ –ø–æ–ª—è
    const { name, price, size, status } = product as any;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å (–º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –ø–æ-—Ä–∞–∑–Ω–æ–º—É: status.alias –∏–ª–∏ status.label)
    // –ï—Å–ª–∏ —É –≤–∞—Å —Å—Ç–∞—Ç—É—Å ‚Äî —ç—Ç–æ –æ–±—ä–µ–∫—Ç c alias, –∏—Å–ø–æ–ª—å–∑—É–µ–º alias:
    const statusAlias = (status?.alias) ? status.alias : 'N/A';

    // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
    let messageText = `<b>${name}</b>\n`;
    messageText += `<b>–¶–µ–Ω–∞:</b> $${price}\n`;
    messageText += `<b>–†–∞–∑–º–µ—Ä:</b> ${size}\n`;
    messageText += `<b>–°—Ç–∞—Ç—É—Å:</b> ${statusAlias}\n`;

    // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏
    const keyboard = new InlineKeyboard()
      .text("–ü–æ–¥—Ä–æ–±–Ω–æ", `productDetails|${product.id}`)
      .text("–ó–∞–∫–∞–∑–∞—Ç—å", `order|${product.id}`);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ¬´–∫–æ—Ä–æ—Ç–∫—É—é¬ª –∫–∞—Ä—Ç–æ—á–∫—É —Ç–æ–≤–∞—Ä–∞
    const cardMsg = await ctx.replyWithPhoto(DEMO_IMAGE_URL, {
      caption: messageText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
    storeMessageId(ctx, cardMsg.message_id);

    log('info', `–ö–æ—Ä–æ—Ç–∫–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ —Ç–æ–≤–∞—Ä–∞ ID ${productId} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.`, payload);
    return cardMsg.message_id;
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∫–æ—Ä–æ—Ç–∫–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞: ${error.message}`, payload);
    const errMsg = await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–≤–∞—Ä–µ.");
    storeMessageId(ctx, errMsg.message_id);
    return null;
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryLayout.ts
// Version: 1.2.0-add-store-button
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "üõí Store" –º–µ–∂–¥—É Back –∏ Next.
// - –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (page == totalPages), –≤–º–µ—Å—Ç–æ Next –≤—ã–≤–æ–¥–∏–º Home (layout|home_page).

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function renderCategoryLayout(
  ctx: BotContext,
  payload: Payload,
  categoryId: number,
  page: number,
  itemsPerPage: number,
): Promise<void> {
  try {
    if (!ctx.chat) return;

    if (!ctx.session.categoryLayoutMessages) ctx.session.categoryLayoutMessages = [];
    if (!ctx.session.categoryPageMessages) ctx.session.categoryPageMessages = [];

    const category = await payload.findByID({
      collection: 'product-categories',
      id: categoryId,
    });
    if (!category) {
      const msg = await ctx.reply("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.");
      storeMessageId(ctx, msg.message_id);
      return;
    }

    // –û–±–ª–æ–∂–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    const bannerUrl = Array.isArray(category.media) && category.media.length > 0
      ? category.media[0].url
      : 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';

    const catMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: `<b>${category.name}</b>\n${category.description || ''}`,
      parse_mode: 'HTML',
    });
    storeMessageId(ctx, catMsg.message_id);
    ctx.session.categoryLayoutMessages.push(catMsg.message_id);

    // –ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    const subcatsResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: categoryId } },
      limit: 999,
    });
    const subcats = subcatsResult.docs;
    if (subcats.length > 0) {
      const subKeyboard = new InlineKeyboard();
      subcats.forEach((sc: any, idx: number) => {
        subKeyboard.text(sc.name, `catalogCategory|${sc.id}|${itemsPerPage}`);
        if ((idx + 1) % 2 === 0) subKeyboard.row();
      });
      const subMsg = await ctx.reply('–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏:', {
        reply_markup: subKeyboard,
      });
      storeMessageId(ctx, subMsg.message_id);
      ctx.session.categoryLayoutMessages.push(subMsg.message_id);
    }

    // –¢–æ–≤–∞—Ä—ã (–ø–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞)
    const pagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = pagination.docs;
    const totalPages = pagination.totalPages;

    if (!products || products.length === 0) {
      const noDataMsg = await ctx.reply("–ù–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.");
      storeMessageId(ctx, noDataMsg.message_id);
      ctx.session.categoryPageMessages.push(noDataMsg.message_id);
      return;
    }

    // –†–µ–Ω–¥–µ—Ä —Ç–æ–≤–∞—Ä–æ–≤
    for (const product of products) {
      const productMsgId = await renderProductCard(ctx, product.id, payload);
      if (productMsgId) {
        ctx.session.categoryPageMessages.push(productMsgId);
      }
    }

    // –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    const navKeyboard = new InlineKeyboard();

    // Back
    // (—É –≤–∞—Å –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–æ–≥–∏–∫–∞, —á—Ç–æ –Ω–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ Back => layout|store_home_page,
    //  –ª–∏–±–æ –µ—Å–ª–∏ page>1 => catalogBackPage|...,
    //  –Ω–æ —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –∏–º–µ–Ω–Ω–æ renderCategoryLayout (–ø–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞),
    //  –æ–±—ã—á–Ω–æ Back => layout|store_home_page).
    navKeyboard.text("Back", "layout|store_home_page");

    // üõí Store (–º–µ–∂–¥—É Back –∏ Next)
    navKeyboard.text("üõí Store", "layout|store_home_page");

    if (page < totalPages) {
      // –ù–µ –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ => Next
      navKeyboard.text("Next", `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`);
    } else {
      // –ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ => Home
      navKeyboard.text("Home", "layout|home_page");
    }

    const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞: ${page} –∏–∑ ${totalPages}`, {
      parse_mode: 'HTML',
      reply_markup: navKeyboard,
    });
    storeMessageId(ctx, navMsg.message_id);
    ctx.session.categoryPageMessages.push(navMsg.message_id);

    log('info', `renderCategoryLayout: page=${page}, categoryId=${categoryId}`, payload);
  } catch (err) {
    log('error', `–û—à–∏–±–∫–∞ renderCategoryLayout: ${err}`, payload);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/handlerCatalogBlock.ts
// Version: 1.4.0-refactored
// [CHANGELOG]
// - –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –∏–∑ CatalogEventHandlers.ts
// - –ò—Å–ø–æ–ª—å–∑—É–µ–º switch-case –¥–ª—è catalogCategory, catalogLoadMore, catalogBackPage
// - –£–¥–∞–ª–∏–ª–∏ manual protect_content (rely on monkey-patch)

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { clearPreviousMessages } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { renderCategoryLayout } from './renderCategoryLayout';
import { renderCategoryNav } from './renderCategoryNav';

/**
 * –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ callback-—Å–æ–±—ã—Ç–∏–π –∫–∞—Ç–∞–ª–æ–≥–∞ (catalogCategory, catalogLoadMore, catalogBackPage).
 * @param cbType - –Ω–∞–ø—Ä–∏–º–µ—Ä "catalogCategory", "catalogLoadMore", "catalogBackPage".
 * @param _unused - –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
 * @param _unused2 - –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
 * @param ctx - –∫–æ–Ω—Ç–µ–∫—Å—Ç –±–æ—Ç–∞.
 * @param payload - —ç–∫–∑–µ–º–ø–ª—è—Ä Payload.
 */
export async function handlerCatalogBlock(
  cbType: string,
  _unused: string,
  _unused2: string | undefined,
  ctx: BotContext,
  payload: Payload,
): Promise<void> {
  try {
    if (!ctx.callbackQuery?.data) {
      throw new Error('–î–∞–Ω–Ω—ã–µ callback –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
    }

    const parts = ctx.callbackQuery.data.split('|');
    const eventType = parts[0]?.trim() ?? '';

    switch (eventType) {
      case 'catalogCategory': {
        // "catalogCategory|<categoryId>|<itemsPerPage>"
        const rawCategoryId = parts[1]?.trim() ?? '';
        const rawItemsPerPage = parts[2]?.trim() ?? '3';

        const categoryId = parseInt(rawCategoryId, 10);
        const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;

        if (isNaN(categoryId)) {
          await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
          break;
        }

        // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –æ–±–Ω—É–ª—è–µ–º –º–∞—Å—Å–∏–≤—ã
        await clearPreviousMessages(ctx);
        ctx.session.categoryLayoutMessages = [];
        ctx.session.categoryPageMessages = [];

        // –†–µ–Ω–¥–µ—Ä–∏–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        await renderCategoryLayout(ctx, payload, categoryId, 1, itemsPerPage);
        log('info', `Callback "catalogCategory|${categoryId}" -> –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.`);
        break;
      }

      case 'catalogLoadMore':
      case 'catalogBackPage': {
        // "catalogLoadMore|<catId>|<page>|<itemsPerPage>"
        // "catalogBackPage|<catId>|<page>|<itemsPerPage>"
        const rawCategoryId = parts[1]?.trim() ?? '';
        const rawPageValue = parts[2]?.trim() ?? '1';
        const rawItemsPerPage = parts[3]?.trim() ?? '3';

        const categoryId = parseInt(rawCategoryId, 10);
        const pageValue = parseInt(rawPageValue, 10);
        const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;

        if (isNaN(categoryId) || isNaN(pageValue)) {
          // –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
          break;
        }

        const direction = (eventType === 'catalogLoadMore') ? 'next' : 'back';
        await renderCategoryNav(ctx, payload, String(categoryId), pageValue, itemsPerPage, direction);
        log('info', `Callback "${eventType}|${rawCategoryId}" -> —Å—Ç—Ä–∞–Ω–∏—Ü–∞ ${pageValue}. direction=${direction}`);
        break;
      }

      default: {
        await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞: ${eventType}`);
        break;
      }
    }

    await ctx.answerCallbackQuery();
  } catch (error: any) {
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞.');
    log('error', `handlerCatalogBlock: ${error.message}`, payload);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock.ts
// Version: 1.1.3-refactored
//
// [CHANGELOG]
// - –ï—Å–ª–∏ –ø–æ–ª–µ description –≤ ButtonBlock –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "ButtonBlock".
// - –ï—Å–ª–∏ ButtonBlock –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ, —Ç–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è –≤—ã–≤–æ–¥–∏—Ç—Å—è –∫–∞–∫ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏.
// - –ï—Å–ª–∏ ButtonBlock —è–≤–ª—è–µ—Ç—Å—è –¥–æ—á–µ—Ä–Ω–∏–º –±–ª–æ–∫–æ–º MessageBlock, —É—Ç–∏–ª–∏—Ç–∞ MessageBlock –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} buttonBlock - –û–±—ä–µ–∫—Ç –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {string} [defaultDescription] - –û–ø–∏—Å–∞–Ω–∏–µ –±–ª–æ–∫–∞ –∫–Ω–æ–ø–æ–∫, –µ—Å–ª–∏ –ø–æ–ª–µ description –Ω–µ –∑–∞–¥–∞–Ω–æ –≤ buttonBlock.
 */
export async function handleButtonBlock(
  ctx: BotContext,
  buttonBlock: any,
  defaultDescription = 'ButtonBlock'
): Promise<void> {
  if (!ctx.chat) {
    log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', undefined);
    return;
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–Ω–æ–ø–æ–∫
  if (!Array.isArray(buttonBlock.buttons) || buttonBlock.buttons.length === 0) {
    log('error', '–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–Ω–æ–ø–æ–∫.', undefined);
    const emptyMsg = await ctx.reply('–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –ø—É—Å—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–Ω–æ–ø–∫–∏.');
    storeMessageId(ctx, emptyMsg.message_id);
    return;
  }

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑ buttonBlock, –µ—Å–ª–∏ –æ–Ω–æ –∑–∞–¥–∞–Ω–æ, –∏–Ω–∞—á–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
  const description = buttonBlock.description || defaultDescription;

  const inlineKeyboard = new InlineKeyboard();

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
  buttonBlock.buttons.forEach((btn: any) => {
    try {
      const callbackData = btn.callback_data || '';
      const buttonText = btn.text;

      switch (btn.callbackType) {
        case 'layout':
        case 'message':
        case 'command':
          inlineKeyboard.text(buttonText, `${btn.callbackType}|${callbackData}`);
          break;
        case 'link':
          inlineKeyboard.url(buttonText, btn.url || '');
          break;
        default:
          inlineKeyboard.text(buttonText, callbackData);
      }

      if (btn.newRow) {
        inlineKeyboard.row();
      }
    } catch (error: any) {
      log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–Ω–æ–ø–∫–∏: ${error.message}`, undefined);
    }
  });

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–∞–º–∏
  try {
    const buttonMsg = await ctx.reply(description, { reply_markup: inlineKeyboard });
    storeMessageId(ctx, buttonMsg.message_id);
    log('info', `–ö–Ω–æ–ø–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã. –°–æ–æ–±—â–µ–Ω–∏–µ ID: ${buttonMsg.message_id}`, undefined);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–Ω–æ–ø–æ–∫: ${error.message}`, undefined);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock.ts
// Version: 1.0.12-refactored
//
// This utility processes a MessageBlock by sending its content using HTML formatting via grammY.
// If a MessageBlock contains a "buttons" field (provided via ButtonBlock), the buttons are attached via an inline keyboard.
// Added option protect_content if the bot is configured to protect content.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';

function getTestMediaUrl(url: string): string {
  console.log(`[DEBUG] Overriding media URL for testing. Original URL: "${url}"`);
  return "https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg";
}

function buildInlineKeyboard(buttons: any[]): InlineKeyboard {
  const keyboard = new InlineKeyboard();
  buttons.forEach((btn: any) => {
    const callbackType = btn.callbackType && btn.callbackType.trim() !== '' ? btn.callbackType : 'layout';
    const callbackData = btn.callback_data || '';
    const data = `${callbackType}|${callbackData}`;
    if (callbackType === 'link' && btn.url) {
      keyboard.url(btn.text, btn.url);
    } else {
      keyboard.text(btn.text, data);
    }
    if (btn.newRow) {
      keyboard.row();
    }
  });
  return keyboard;
}

export async function processMessageBlock(ctx: BotContext, blockData: any): Promise<void> {
  if (!ctx.chat) return;
  const text: string = blockData.text;
  try {
    const replyOptions: any = {
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    };

    let buttonsArray: any[] = [];
    if (Array.isArray(blockData.buttons) && blockData.buttons.length > 0) {
      if (blockData.buttons[0]?.buttons) {
        blockData.buttons.forEach((btnBlock: any) => {
          if (Array.isArray(btnBlock.buttons)) {
            buttonsArray = buttonsArray.concat(btnBlock.buttons);
          }
        });
      } else {
        buttonsArray = blockData.buttons;
      }
      if (buttonsArray.length > 0) {
        replyOptions.reply_markup = buildInlineKeyboard(buttonsArray);
      }
    }

    let sentMsg;
    if (blockData.media && typeof blockData.media.url === 'string' && blockData.media.url.trim() !== "") {
      const mediaUrl = getTestMediaUrl(blockData.media.url);
      console.log(`[DEBUG] blockData.media:`);
      console.dir(blockData.media, { depth: null });
      console.log(`[DEBUG] Sending photo with test URL: "${mediaUrl}" and caption: "${text}"`);
      sentMsg = await ctx.replyWithPhoto(mediaUrl, {
        caption: text,
        ...replyOptions,
      });
    } else {
      sentMsg = await ctx.reply(text, replyOptions);
    }
    if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
      ctx.session.previousMessages.push(sentMsg.message_id);
      console.log(`[DEBUG] Stored message ID: ${sentMsg.message_id}. Current previousMessages: ${ctx.session.previousMessages}`);
    }
  } catch (error: any) {
    console.error('Error processing MessageBlock:', error);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/registerBots.ts
// Version: 1.0.0-refactored
// –ü–æ–¥—Ä–æ–±–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ –∫–æ–¥–µ:
// - –≠—Ç–æ—Ç —Ñ–∞–π–ª –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é (–∑–∞–ø—É—Å–∫) –≤—Å–µ—Ö –±–æ—Ç–æ–≤ –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ Payload.
// - –§—É–Ω–∫—Ü–∏—è registerBots –∏—â–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤ –≤ CMS, —Å–æ–∑–¥–∞–µ—Ç –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç BotConfig –∏ –≤—ã–∑—ã–≤–∞–µ—Ç initBot.
// - –§–∞–π–ª –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –≤ registerBots –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –ø—É—Ç–∞–Ω–∏—Ü—ã —Å —Ç–µ—Ä–º–∏–Ω–æ–º "initialize".

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';
import { initBot } from '@/plugins/TelegramAPI/utils/BotUtils/initBot';

import type {
  UnifiedBotConfig,
  UnifiedBotInterface,
} from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ UnifiedBotConfig –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ CMS.
 */
export function createUnifiedBotConfig(rawBotData: any): UnifiedBotConfig {
  const defaultInterface: UnifiedBotInterface = {
    blocks: [],
    defaultStartLayout: 'start',
    defaultFirstVisitLayout: 'start_first_visit',
    total_visit: 0,
  };

  return {
    id: rawBotData.id,
    name: rawBotData.name,
    token: rawBotData.token,
    description: rawBotData.description,
    enabled: rawBotData.enabled,
    protectContent: rawBotData.protectContent,
    initialization_status: rawBotData.initialization_status,
    last_initialized: rawBotData.last_initialized,
    interface: {
      blocks: Array.isArray(rawBotData.interface?.blocks)
        ? rawBotData.interface.blocks
        : defaultInterface.blocks,
      defaultStartLayout:
        rawBotData.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout:
        rawBotData.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit:
        typeof rawBotData.interface?.total_visit === 'number'
          ? rawBotData.interface.total_visit
          : defaultInterface.total_visit,
    },
    allowedCommands: [],
  };
}

/**
 * –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (–∑–∞–ø—É—Å–∫–∞) –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤.
 * –ò—â–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤ –≤ CMS –∏ –≤—ã–∑—ã–≤–∞–µ—Ç initBot –¥–ª—è –∫–∞–∂–¥–æ–≥–æ.
 */
export async function registerBots(payload: Payload): Promise<void> {
  try {
    log('info', '–ü–æ–∏—Å–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤...', payload);
    const { docs: bots } = await payload.find({
      collection: 'bots',
      where: { enabled: { equals: 'enabled' } },
      limit: 999,
    });
    log('info', `–ù–∞–π–¥–µ–Ω–æ ${bots.length} –±–æ—Ç–æ–≤ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.`, payload);
    for (const botData of bots) {
      const unifiedBotData = createUnifiedBotConfig(botData);
      if (unifiedBotData.enabled !== 'enabled') {
        log('info', `–ë–æ—Ç "${unifiedBotData.name}" –æ—Ç–∫–ª—é—á—ë–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º.`, payload);
        continue;
      }
      const botConfig = new BotConfig(unifiedBotData);
      console.log('BotConfig:', JSON.stringify(botConfig, null, 2));
      await initBot(payload, botConfig);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –±–æ—Ç–æ–≤: ${error.message}`, payload);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/initBot.ts
// Version: 1.0.0-refactored
// –ü–æ–¥—Ä–æ–±–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ –∫–æ–¥–µ:
// - –≠—Ç–æ—Ç —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ—É–Ω–∫—Ü–∏—é initBot, –∫–æ—Ç–æ—Ä–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç (–∑–∞–ø—É—Å–∫–∞–µ—Ç) –æ–¥–Ω–æ–≥–æ –±–æ—Ç–∞.
// - –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç middlewares, –∫–æ–º–∞–Ω–¥—ã –∏ callback-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞.
// - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è initBot –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Ñ–∞–π–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –±–æ—Ç–æ–≤.

import type { Payload } from 'payload';
import { Bot as TelegramBot } from 'grammy';
import { setupMiddlewares } from '@/plugins/TelegramAPI/utils/BotUtils/setupMiddlewares';
import { setupCommands, buildAllowedCommands } from '@/plugins/TelegramAPI/utils/BotUtils/setupCommands';
import { setupCallbacks } from '@/plugins/TelegramAPI/utils/BotUtils/setupCallbacks';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

/**
 * –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–∑–∞–ø—É—Å–∫–∞) –æ–¥–Ω–æ–≥–æ –±–æ—Ç–∞.
 * –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç middlewares, –∫–æ–º–∞–Ω–¥—ã, callback-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞.
 */
export async function initBot(payload: Payload, botConfig: BotConfig): Promise<void> {
  try {
    if (!botConfig.token) {
      log('error', `–ü—Ä–æ–ø—É—â–µ–Ω –±–æ—Ç "${botConfig.name}": –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω.`, payload);
      return;
    }
    const bot = new TelegramBot<BotContext>(botConfig.token);
    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º middlewares
    setupMiddlewares(bot, botConfig, payload);

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∫–æ–º–∞–Ω–¥
    botConfig.allowedCommands = buildAllowedCommands(botConfig);
    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã –∏ callback-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    setupCommands(bot, botConfig, payload);
    setupCallbacks(bot, botConfig, payload);

    if (botConfig.description) {
      try {
        await bot.api.setMyDescription(botConfig.description);
        log('info', '–û–ø–∏—Å–∞–Ω–∏–µ –±–æ—Ç–∞ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.', payload);
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ–ø–∏—Å–∞–Ω–∏—è –±–æ—Ç–∞: ${error.message}`, payload);
      }
    }
    bot.start();
    log('info', `ü§ñ –ë–æ—Ç "${botConfig.name}" —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: {
        initialization_status: 'Initialized',
        last_initialized: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞ "${botConfig.name}": ${error.message}`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: { initialization_status: 'Error' },
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/setupCallbacks.ts
// Version: 1.0.3-refactored
// [CHANGELOG]
// - –†–∞–Ω–µ–µ –≤—ã–∑—ã–≤–∞–ª–∏ handleCatalogEvent(...) –∏–∑ CatalogEventHandlers.ts
//   —Ç–µ–ø–µ—Ä—å –≤—ã–∑—ã–≤–∞–µ–º handlerCatalogBlock(...) –∏–∑ handlerCatalogBlock.ts
// - –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ (layout|..., message|..., command|...) –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è.

import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
// [EDIT START] –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é handlerCatalogBlock
import { handlerCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/handlerCatalogBlock';
import { goBackState } from '@/plugins/TelegramAPI/utils/SystemUtils/goBackState';
import type { Bot as TelegramBot } from 'grammy';
import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import type { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

export function setupCallbacks(
    bot: TelegramBot<BotContext>,
    botConfig: BotConfig,
    payload: Payload
): void {
  bot.on('callback_query:data', async (ctx) => {
    if (!ctx.callbackQuery || !ctx.callbackQuery.data) return;
    try {
      const data = ctx.callbackQuery.data;
      const parts = data.split('|');
      const cbType = parts[0]?.trim() ?? '';
      const callbackAlias = parts[1]?.trim() ?? '';

      // –ï—Å–ª–∏ –∫–æ–ª–±—ç–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å "catalog", –ø–µ—Ä–µ–¥–∞—ë–º –≤ handlerCatalogBlock
      if (cbType.startsWith('catalog')) {
        // [EDIT] –≤—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é handlerCatalogBlock
        await handlerCatalogBlock(cbType, callbackAlias, '', ctx, payload);
        log('info', `Callback "${cbType}|${callbackAlias}" –æ–±—Ä–∞–±–æ—Ç–∞–Ω —á–µ—Ä–µ–∑ handlerCatalogBlock.`, payload);
      }
      else if (cbType === 'layout' && callbackAlias === 'go_back_state') {
        await goBackState(ctx, payload, botConfig);
      }
      else if (cbType === 'layout' && callbackAlias === 'store_home_page') {
        await sendLayoutBlock(ctx, botConfig, payload, 'store_home_page');
      }
      else {
        switch (cbType) {
          case 'layout': {
            const layoutBlock = botConfig.interface.blocks.find(
                (block: any) => block.alias === callbackAlias
            );
            if (layoutBlock) {
              ctx.session.previousState = layoutBlock;
              await sendLayoutBlock(ctx, botConfig, payload, callbackAlias);
            } else {
              await ctx.reply(`–û—à–∏–±–∫–∞: –õ–µ–π–∞—É—Ç —Å alias "${callbackAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
            }
            break;
          }
          case 'message': {
            await processMessageBlock(ctx, { text: callbackAlias });
            log('info', `MessageBlock "${callbackAlias}" —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.`, payload);
            break;
          }
          case 'command': {
            if (callbackAlias === 'go_back_state') {
              await goBackState(ctx, payload, botConfig);
            } else {
              await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${callbackAlias}`);
            }
            break;
          }
          default: {
            await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø callback: ${cbType}`);
          }
        }
      }

      await ctx.answerCallbackQuery();
    } catch (error: any) {
      log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback_query: ${error.message}`, payload);
    }
  });
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/setupCommands.ts
// Version: 1.0.4
// [CHANGELOG]
// - –£–¥–∞–ª–∏–ª–∏ manual protect_content –∏–∑ ctx.reply(...).
// - –ü—Ä–∏ /start —É–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ /start, –∞ –∑–∞—Ç–µ–º –ª–∏–±–æ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ª–µ–π–∞—É—Ç, –ª–∏–±–æ —à–ª—ë–º fallback –±–µ–∑ protect_content (–≤–µ–¥—å —Ç–µ–ø–µ—Ä—å –æ–Ω–æ –¥–æ–±–∞–≤–∏—Ç—Å—è —á–µ—Ä–µ–∑ "–º–æ–Ω–∫–∏-–ø–∞—Ç—á").

import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { processClient } from '@/plugins/TelegramAPI/utils/ClientUtils/processClient';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import type { Payload } from 'payload';
import type { Bot as TelegramBot } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import type { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

export function buildAllowedCommands(botConfig: BotConfig): string[] {
  const allowed: string[] = [];
  allowed.push('start');
  // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å /help –∏ —Ç.–¥.
  return allowed;
}

export function setupCommands(
    bot: TelegramBot<BotContext>,
    botConfig: BotConfig,
    payload: Payload
): void {
  bot.command('start', async (ctx) => {
    try {
      // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ /start
      if (ctx.session.startMessageId) {
        try {
          await ctx.api.deleteMessage(ctx.chat.id, ctx.session.startMessageId);
        } catch (delError: any) {
          log('error', `–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–µ–µ /start: ${delError.message}`, payload);
        }
      }
      // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º ID –Ω–æ–≤–æ–≥–æ /start
      if (ctx.msg?.message_id) {
        ctx.session.startMessageId = ctx.msg.message_id;
      }

      log('info', `–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}.`, payload);
      const telegramId = ctx.from?.id;
      if (!telegramId) {
        await ctx.reply('–û—à–∏–±–∫–∞: Telegram ID –Ω–µ –Ω–∞–π–¥–µ–Ω.');
        return;
      }
      const client = await processClient(payload, telegramId, botConfig.id, {
        first_name: ctx.from?.first_name,
        last_name: ctx.from?.last_name,
        username: ctx.from?.username,
      });
      ctx.session.isBanned = client.isBanned;

      if (!client.isBanned) {
        const layoutAlias =
            client.total_visit === 1
                ? botConfig.interface.defaultFirstVisitLayout
                : botConfig.interface.defaultStartLayout;

        if (layoutAlias) {
          await sendLayoutBlock(ctx, botConfig, payload, layoutAlias);
        } else {
          await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
        }
      } else {
        await ctx.reply('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.');
      }
      ctx.session.botConfig = botConfig;
    } catch (error: any) {
      log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ /start: ${error.message}`, payload);
      await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ /start.');
    }
  });
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/setupMiddlewares.ts
// Version: 1.1.0
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω "–º–æ–Ω–∫–∏-–ø–∞—Ç—á" –¥–ª—è ctx.reply –∏ ctx.replyWithPhoto, —á—Ç–æ–±—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
//   —Å—Ç–∞–≤–∏—Ç—å protect_content = ctx.session.botConfig?.protectContent ?? false.
// - –£–¥–∞–ª—è–µ–º —Ä—É—á–Ω–æ–µ protect_content –∏–∑ –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö —Ñ–∞–π–ª–æ–≤.

import { session } from 'grammy';
import type { BotContext, SessionData } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { bannedClientHook } from '@/plugins/TelegramAPI/utils/ClientUtils/bannedClient';
import { inputMessageFilter } from '@/plugins/TelegramAPI/utils/SystemUtils/inputMessageFilter';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { Bot as TelegramBot } from 'grammy';
import type { Payload } from 'payload';

export function setupMiddlewares(bot: TelegramBot<BotContext>, botConfig: any, payload: Payload): void {
  // 1) Session
  bot.use(
    session<SessionData, BotContext>({
      initial: () => ({
        previousMessages: [],
        stateStack: [],
        previousState: undefined,
        currentState: undefined,
        isBanned: false,
        botConfig: botConfig,
        startMessageId: undefined,
      }),
    })
  );

  // 2) –ë–ª–æ–∫–∏—Ä—É–µ–º, –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –∑–∞–±–∞–Ω–µ–Ω
  bot.use(bannedClientHook(payload));

  // 3) –§–∏–ª—å—Ç—Ä—É–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è (SQL-–∏–Ω—ä–µ–∫—Ü–∏–∏, slash-–∫–æ–º–∞–Ω–¥—ã –∏ —Ç.–¥.)
  bot.use(inputMessageFilter);

  // 4) "–ú–æ–Ω–∫–∏-–ø–∞—Ç—á" –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ protect_content
  bot.use(async (ctx, next) => {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    const originalReply = ctx.reply.bind(ctx);
    const originalReplyWithPhoto = ctx.replyWithPhoto.bind(ctx);

    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º ctx.reply
    ctx.reply = async function (text, options = {}) {
      if (typeof options.protect_content === 'undefined') {
        options.protect_content = ctx.session.botConfig?.protectContent ?? false;
      }
      return originalReply(text, options);
    };

    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º ctx.replyWithPhoto
    ctx.replyWithPhoto = async function (photo, options = {}) {
      if (typeof options.protect_content === 'undefined') {
        options.protect_content = ctx.session.botConfig?.protectContent ?? false;
      }
      return originalReplyWithPhoto(photo, options);
    };

    // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º ctx.replyWithDocument, ctx.replyWithAudio –∏ —Ç.–¥.

    await next();
  });

  log('info', 'Middlewares —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã.', payload);
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/BotConfig.ts
// Version: 1.4.9-extended
//
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –¥–æ–±–∞–≤–ª–µ–Ω–æ –Ω–æ–≤–æ–µ –ø–æ–ª–µ allowedCommands (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ),
// –∞ —Ç–∞–∫–∂–µ —É—á—Ç–µ–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—è protectContent –≤ UnifiedBotConfig
// (–¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –æ—à–∏–±–∫–∏ TS2339). –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏–∑ 1.4.7-refactored.

import type { UnifiedBotConfig, UnifiedBotInterface } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

// –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –±–æ—Ç–∞
const defaultInterface: UnifiedBotInterface = {
  blocks: [],
  defaultStartLayout: 'start',
  defaultFirstVisitLayout: 'start_first_visit',
  total_visit: 0,
};

/**
 * –ö–ª–∞—Å—Å BotConfig –∏–Ω–∫–∞–ø—Å—É–ª–∏—Ä—É–µ—Ç –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞ (–ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∏–∑ UnifiedBotConfig),
 * –≤–∫–ª—é—á–∞—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (protectContent, allowedCommands, –∏ —Ç.–¥.).
 */
export class BotConfig {
  public id: number;
  public name: string;
  public token: string;
  public description?: string;
  public enabled: string;
  public initialization_status: string;
  public last_initialized?: string;
  public interface: UnifiedBotInterface;
  public protectContent: boolean;

  // [CHANGE] –î–æ–±–∞–≤–ª–µ–Ω–æ –Ω–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è —Å–ø–∏—Å–∫–∞ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∫–æ–º–∞–Ω–¥
  public allowedCommands?: string[];

  constructor(data: UnifiedBotConfig) {
    this.id = data.id;
    this.name = data.name;
    this.token = data.token;
    this.description = data.description;
    this.enabled = data.enabled;
    this.initialization_status = data.initialization_status;
    this.last_initialized = data.last_initialized;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –±–æ—Ç–∞
    this.interface = {
      blocks: data.interface?.blocks ?? defaultInterface.blocks,
      defaultStartLayout: data.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: data.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit:
        typeof data.interface?.total_visit === 'number'
          ? data.interface?.total_visit
          : defaultInterface.total_visit,
    };

    // –ï—Å–ª–∏ –ø–æ–ª–µ protectContent –µ—Å—Ç—å –≤ data, –∏—Å–ø–æ–ª—å–∑—É–µ–º, –∏–Ω–∞—á–µ false
    this.protectContent = data.protectContent ?? false;

    // –ï—Å–ª–∏ –ø–æ–ª–µ allowedCommands —É–∂–µ –µ—Å—Ç—å –≤ data, –±–µ—Ä—ë–º –µ–≥–æ. –ò–Ω–∞—á–µ ‚Äî –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
    this.allowedCommands = data.allowedCommands ?? [];
  }

  get telegramApiToken(): string {
    return this.token;
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/goBackState.ts
// Version: 1.0.4-goBack_stack
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò—Å–ø–æ–ª—å–∑—É–µ–º stateStack –∏ currentState –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.

import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { clearPreviousMessages } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

export async function goBackState(ctx: BotContext, payload: Payload, botConfig: any): Promise<void> {
  try {
    // –û—á–∏—â–∞–µ–º –≤—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    await clearPreviousMessages(ctx);

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ —Å—Ç–µ–∫–∞, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    let previousState = null;
    if (ctx.session.stateStack && ctx.session.stateStack.length > 0) {
      previousState = ctx.session.stateStack.pop();
    } else if (ctx.session.currentState) {
      // –ï—Å–ª–∏ —Å—Ç–µ–∫ –ø—É—Å—Ç, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–∫ fallback
      previousState = ctx.session.currentState;
    }

    if (!previousState || !previousState.alias) {
      await ctx.reply('–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
      return;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    ctx.session.currentState = previousState;

    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º layout –ø–æ alias –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    await sendLayoutBlock(ctx, botConfig, payload, previousState.alias);
    log('info', '–ö–æ–º–∞–Ω–¥–∞ go_back_state –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–æ–∑–≤—Ä–∞—â—ë–Ω –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.', payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã go_back_state: ${error.message}`, payload);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.');
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages.ts
// Version: 1.3.6-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò–º–ø–æ—Ä—Ç—ã —Ç–∏–ø–æ–≤ SessionData –∏ BotContext –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –æ–±—â–∏–π —Ñ–∞–π–ª TelegramBlocksTypes.ts.

import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function clearPreviousMessages(ctx: BotContext): Promise<void> {
  if (!ctx.chat || !ctx.session || !Array.isArray(ctx.session.previousMessages)) {
    log('debug', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.');
    return;
  }
  const chatId = ctx.chat.id;
  const messageIds = ctx.session.previousMessages;
  try {
    for (const msgId of messageIds) {
      try {
        await ctx.api.editMessageReplyMarkup(chatId, msgId, { reply_markup: undefined });
      } catch (error: any) {}
      try {
        await ctx.api.deleteMessage(chatId, msgId);
      } catch (error: any) {}
    }
  } catch (err: any) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏
  } finally {
    ctx.session.previousMessages = [];
  }
}

export function storeMessageId(ctx: BotContext, messageId: number): void {
  if (!messageId) return;
  if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
    ctx.session.previousMessages.push(messageId);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/SystemUtils/Logger.ts
// üìå –í–µ—Ä—Å–∏—è: 1.1.0
//
// [CHANGELOG]
// - –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–º–ø–æ—Ä—Ç `Payload` –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
// - –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ `Payload`.
// - –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ –±–ª–æ–∫–µ Payload CMS –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.

import type { Payload } from 'payload';

/**
 * –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {string} level - –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ('info', 'debug', 'error').
 * @param {string} message - –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {Payload} [payload] - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞.
 * @param {Record<string, any>} [context] - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–±—ä–µ–∫—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞).
 */
export function log(
  level: 'info' | 'debug' | 'error',
  message: string,
  payload?: Payload,
  context?: Record<string, any>
): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

  // –í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
  if (context && Object.keys(context).length > 0) {
    console.log(logMessage, context);
  } else {
    console.log(logMessage);
  }

  // –í—ã–≤–æ–¥ —á–µ—Ä–µ–∑ Payload CMS, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ
  if (payload?.logger && typeof payload.logger[level] === 'function') {
    try {
      payload.logger[level](message, context || {});
    } catch (err: any) {
      console.error(
        `[${timestamp}] [ERROR] –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ Payload CMS: ${err.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`
      );
    }
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/inputMessageFilter.ts
// Version: 1.0.8
// [CHANGELOG]
// - –ù–µ —Ç—Ä–æ–≥–∞–µ–º protect_content, —Ç–∞–∫ –∫–∞–∫ —Ç–µ–ø–µ—Ä—å –æ–Ω–æ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ setupMiddlewares.ts "–º–æ–Ω–∫–∏-–ø–∞—Ç—á".
// - –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É SQL-–∏–Ω—ä–µ–∫—Ü–∏–π, slash-–∫–æ–º–∞–Ω–¥, –∏ –ø—Ä–æ–ø—É—Å–∫ callback_query.

import { MiddlewareFn } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –∑–∞—â–∏—Ç—ã
const sqlInjectionPattern = /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|ALTER|EXEC|UNION|--|WHERE|HAVING|GROUP\s+BY|ORDER\s+BY|EXECUTE|INTO|LIKE|REPLACE|TRUNCATE|SHOW|DESCRIBE)\b)/i;
const dangerousCharsPattern = /[`$;"'\\]/g;
const scriptTagPattern = /<script\b[^>]*>(.*?)<\/script>/gi;
const evalPattern = /\beval\s*\(.*\)/gi;

const maxCommandLength = 100;

export const inputMessageFilter: MiddlewareFn<BotContext> = async (ctx, next) => {
  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º callback_query –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ slash-–∫–æ–º–∞–Ω–¥
  if (ctx.callbackQuery) {
    return next();
  }

  const text = ctx.message?.text;
  if (typeof text === 'string') {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ–ø–∞—Å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    if (
      text.length > 1000 ||
      sqlInjectionPattern.test(text) ||
      dangerousCharsPattern.test(text) ||
      scriptTagPattern.test(text) ||
      evalPattern.test(text)
    ) {
      await blockMessage(ctx, '–°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –æ–ø–∞—Å–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏. –£–¥–∞–ª—è–µ–º...');
      return;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ slash-–∫–æ–º–∞–Ω–¥—ã
    if (text.startsWith('/')) {
      const trimmed = text.trim();
      if (trimmed.length > maxCommandLength) {
        await blockMessage(ctx, '–ö–æ–º–∞–Ω–¥–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è –∏ –±—É–¥–µ—Ç –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.');
        return;
      }
      const cmdWithoutSlash = trimmed.slice(1).split(' ')[0] || '';
      const allowedCommands = ctx.session.botConfig?.allowedCommands || [];

      if (!allowedCommands.includes(cmdWithoutSlash)) {
        await blockMessage(ctx, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ.');
        return;
      }
      // –î–æ–ø—É—Å—Ç–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞
      return next();
    }

    // –ù–µ callback, –Ω–µ slash-–∫–æ–º–∞–Ω–¥–∞ => —É–¥–∞–ª—è–µ–º
    await blockMessage(ctx, '–û–±—ã—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏.');
    return;
  }

  // –ï—Å–ª–∏ –≤–æ–æ–±—â–µ –Ω–µ—Ç —Ç–µ–∫—Å—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ñ–æ—Ç–æ –±–µ–∑ –ø–æ–¥–ø–∏—Å–∏) => —É–¥–∞–ª—è–µ–º
  if (ctx.message) {
    await blockMessage(ctx, '–¢–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è / –∏–ª–∏ inline-–∫–Ω–æ–ø–∫–∏.');
  }
};

async function blockMessage(ctx: BotContext, notifyText: string) {
  try {
    const replyMsg = await ctx.reply(notifyText);
    if (ctx.chat && ctx.msg) {
      await ctx.api.deleteMessage(ctx.chat.id, ctx.msg.message_id);
    }
  } catch (err) {
    // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
  }
}
// Path: src/plugins/TelegramAPI/types/TelegramBlocksTypes.ts
// Version: 2.1.0
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–ª—è categoryLayoutMessages –∏ categoryPageMessages –≤ SessionData,
//   —á—Ç–æ–±—ã —Ä–∞–∑–¥–µ–ª—å–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –æ–±–ª–æ–∂–∫—É/–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Ç–æ–≤–∞—Ä—ã/–ø–∞–Ω–µ–ª—å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.

import type { Context, SessionFlavor } from 'grammy';
import type { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

export enum BlockType {
  Layout = 'layout-blocks',
  Catalog = 'catalog-blocks',
  Message = 'message-blocks',
  Button = 'button-blocks',
  Command = 'command-blocks',
}

export interface TelegramLayoutBlock {
  blockType: BlockType.Layout;
  name: string;
  alias: string;
  blocks: TelegramSubBlock[];
  clearPreviousMessages?: boolean;
}

export interface TelegramCatalogBlock {
  blockType: BlockType.Catalog;
  name: string;
  alias: string;
  itemsPerPage?: number;
}

export interface TelegramMessageBlock {
  blockType: BlockType.Message;
  text: string;
}

export interface TelegramButtonBlock {
  blockType: BlockType.Button;
  text: string;
  callbackType: 'link' | 'message' | 'layout' | 'command';
}

export interface TelegramCommandBlock {
  blockType: BlockType.Command;
  command: string;
  responseText: string;
}

export type TelegramSubBlock =
  | TelegramLayoutBlock
  | TelegramCatalogBlock
  | TelegramMessageBlock
  | TelegramButtonBlock
  | TelegramCommandBlock;

export interface FromData {
  first_name?: string;
  last_name?: string;
  username?: string;
}

export interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

export interface UnifiedBotInterface {
  blocks: TelegramSubBlock[];
  defaultStartLayout: string;
  defaultFirstVisitLayout: string;
  total_visit: number;
}

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
  allowedCommands?: string[];
  protectContent?: boolean;
}

export interface SessionData {
  previousMessages: number[];
  stateStack: any[];
  previousState?: any;
  currentState?: TelegramLayoutBlock;
  isBanned: boolean;
  botConfig?: BotConfig;
  startMessageId?: number;

  // [EDIT START] –ù–æ–≤—ã–µ –ø–æ–ª—è
  categoryLayoutMessages?: number[];  // –æ–±–ª–æ–∂–∫–∞ –∏ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏
  categoryPageMessages?: number[];    // —Ç–æ–≤–∞—Ä—ã –∏ –ø–∞–Ω–µ–ª—å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
  // [EDIT END]
}

export type BotContext = Context & SessionFlavor<SessionData>;