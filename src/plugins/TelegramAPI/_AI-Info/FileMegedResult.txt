–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏ –≤ TelegramAPI - –ø–ª–∞–≥–∏–Ω–µ
–í —ç—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ –Ω–∏–∂–µ, —è –ø—Ä–∏—à–ª—é –∫–æ–¥ –ø–ª–∞–≥–∏–Ω–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –ø–∞–º—è—Ç—å –¥–∏–∞–ª–æ–≥–∞ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π –¥–æ—Ä–∞–±–æ—Ç–∫–∏.
–≠—Ç–∞ –≤–µ—Ä—Å–∏—è —Å—á–∏—Ç–∞–µ—Ç—Å—è –°–¢–ê–ë–ò–õ–¨–ù–û–ô –∏ –º—ã –±—É–¥–µ–º –µ—ë –¥–æ—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª.

–ù–∞ –ø–µ—Ä–≤–æ–º —ç—Ç–∞–ø–µ –¥–æ—Ä–∞–±–æ—Ç–æ–∫ –Ω–∞–º –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫–∏ —Ç–∏–ø–∏–∑–∞—Ü–∏–∏, –∞ —Ç–æ—á–Ω–µ–µ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –∏ –∏—Ö —Ç–∏–ø–æ–≤ –≤ –æ–¥–∏–Ω –æ–±—â–∏–π —Ñ–∞–π–ª, –ø—Ä–∏ —ç—Ç–æ –æ–±–Ω–æ–≤–∏–≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ–π —Ñ–∞–π–ª—ã –ø–ª–∞–≥–∏–Ω–∞.
–í–∞–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –∏ –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ—à–∏–±–æ–∫. –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤–Ω–æ—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ –≤ —Ç–µ –º–µ—Å—Ç–∞ –∫–æ–¥–∞ –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –¥–∞–Ω–Ω–æ–π –∑–∞–¥–∞—á–µ, –Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞—è –¥—Ä—É–≥–∏–µ —á–∞—Å—Ç–∏ —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ.

-------------------------

–ò–ù–°–¢–†–£–ö–¶–ò–ò. –ó–ê–ü–û–ú–ù–ò - –í–ê–ñ–ù–û!
1. –í—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–π –ø—É—Ç–∏ –¥–æ —Ñ–∞–π–ª–æ–≤
2. –ü–æ–¥—Ä–æ–±–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç—Ä–∞–∏–∏ –≤ –∫–æ–¥–µ
3. –ü–æ–º–Ω–∏ –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞
4. –ó–∞–ø–æ–º—è–Ω–∞–π –≤—Å–µ –æ—à–∏–±–∫–∏ –∏ —Ä–µ—à–µ–Ω–∏—è –∫ –Ω–∏–º.
5. –í –∫–æ–º–µ–Ω—Ç–∞—Ä–∏—è—Ö –∫–æ–¥–∞ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—É—Ç—å –¥–æ —Ñ–∞–π–ª–∞ –æ—Ç –∫–æ—Ä–Ω—è.
6. –ö–∞–∂–¥—ã–π —Ñ–∞–π–ª –ø–æ–º–µ—á–∞–π –∫–æ–º–µ–Ω—Ç–∞–º–∏ –≤–µ—Ä—Å–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
7. –∏—Å—Ç—Ä—É–∫–∏—è –ø–æ —à–∞–≥–∞–º.
8. –ó–∞–≤–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã, –∑–∞–ø–æ–º—è–Ω–∞–π –æ—Ç–≤–µ—Ç—ã –Ω–∞ –Ω–∏—Ö
9. –û—Ç–≤–µ—á–∞–π –≤—Å–µ–≥–¥–∞ –ø–æ —Ä—É—Å—Å–∫–∏
10. –ù–µ —É–¥–∞–ª—è–π —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª, –º—ã –¥–æ—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞
11. –ú–µ—Å—Ç–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞ –ø–æ–º–µ—á–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏
12. –ø—Ä–æ—Å—Ç–∞–≤–ª—è–µ–º TODO —Ç–∞–º –≥–¥–µ —ç—Ç–æ –Ω–µ–±–æ—Ö–æ–¥–∏–º–æ.
13. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–æ–¥ —Ñ–∞–π–ª–æ–≤ –≤ —Å–≤—è–∑–∫–µ, –Ω–µ –¥–æ–ø—É—Å–∫–∞–π –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–≥–∏–∫–∏ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞.
14. –ü—Ä–∏–¥–µ—Ä–∂–∏–≤–∞–π—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–≤ Payloadcms 3 –∏ grammyjs

–ó–∞–ø–æ–º–Ω–∏ —ç—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ —á—ë—Ç–∫–æ —Å–ª–µ–¥—É–π –∏–º –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏–π.
–ó–∞—Ä–∞–Ω–∏–µ –±–ª–∞–≥–æ–¥–∞—Ä—é!

-------------------------

// Path: src/plugins/TelegramAPI/index.TelegramAPI.ts
// Version: 5.7.0
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞ initializeBots.ts.
// –ö–æ–ª–ª–µ–∫—Ü–∏–∏ Bots –∏ Clients —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç—Å—è –≤ –ø–ª–∞–≥–∏–Ω–µ.
import type { Payload, Config, Plugin } from 'payload';
import Bots from '@/collections/TelegramAPI/Bots';
import Clients from '@/collections/TelegramAPI/Clients';
import { initializeBots } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const TelegramAPIPlugin: Plugin = (incomingConfig: Config): Config => {
  return {
    ...incomingConfig,
    collections: [
      ...(incomingConfig.collections || []),
      Bots,
      Clients,
    ],
    onInit: async (payload: Payload) => {
      log('info', 'TelegramAPIPlugin initialization started.', payload);
      await initializeBots(payload);
      log('info', 'TelegramAPIPlugin initialized successfully.', payload);
    },
  };
};

export default TelegramAPIPlugin;
// Path: src/plugins/TelegramAPI/utils/ClientUtils/processClient.ts
// Version: 1.3.8-stable
//
// [CHANGELOG]
// - –ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ–ª–µ status –Ω–µ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —á–µ—Ä–µ–∑ –≤–µ–±—Ö—É–∫/–∫–æ–ª–ª–µ–∫—Ü–∏—é.
// - –î–æ–±–∞–≤–ª–µ–Ω–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è client.status –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è/–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞.
// - –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–æ –ø–æ–ª–µ bots –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫ —Ç–∏–ø–æ–≤.
// - –ü–æ–ª–µ status –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è –±–æ—Ç–æ–º ‚Äì –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

interface FromData {
  first_name?: string;
  last_name?: string;
  username?: string;
}

export async function processClient(
  payload: Payload,
  telegramId: number,
  botId: number,
  fromData: FromData
): Promise<any> {
  try {
    log('info', `[processClient] Searching for client with telegram_id=${telegramId} and bot=${botId}`, payload);

    const { docs } = await payload.find({
      collection: 'clients',
      where: { telegram_id: { equals: telegramId } },
      limit: 1,
    });

    let client: any;

    if (!docs || docs.length === 0) {
      log('info', "[processClient] No existing client found, creating a new one...", payload);
      client = await payload.create({
        collection: 'clients',
        data: {
          telegram_id: telegramId,
          bots: [botId],
          first_name: fromData.first_name ?? "",
          last_name: fromData.last_name ?? "",
          user_name: fromData.username || 'anonymous_user',
          total_visit: 1,
          last_visit: new Date().toISOString(),
          enabled: "enabled"
          // –ü–æ–ª–µ status –Ω–µ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è, —á—Ç–æ–±—ã –∑–Ω–∞—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å —á–µ—Ä–µ–∑ defaultValue –∏–ª–∏ beforeChange-—Ö—É–∫ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏.
        },
      });
    } else {
      const existingClient = docs[0]!;
      log('info', `[processClient] Client found: ID=${existingClient.id}`, payload);
      let botsArray: any[] = Array.isArray(existingClient.bots)
        ? existingClient.bots
        : existingClient.bots ? [existingClient.bots] : [];
      if (!botsArray.some(b =>
        b != null && typeof b === 'object'
          ? b.id !== undefined && b.id.toString() === botId.toString()
          : b != null && b.toString() === botId.toString()
      )) {
        botsArray.push(botId);
        log('info', `[processClient] Bot ${botId} added to client ${existingClient.id}`, payload);
      }
      client = await payload.update({
        collection: 'clients',
        id: existingClient.id,
        data: {
          bots: botsArray,
          first_name: fromData.first_name ?? existingClient.first_name ?? "",
          last_name: fromData.last_name ?? existingClient.last_name ?? "",
          user_name: fromData.username || existingClient.user_name || 'anonymous_user',
          last_visit: new Date().toISOString(),
          total_visit: (existingClient.total_visit ?? 0) + 1,
        },
      });
    }

    log('debug', `[processClient] Client status: ${client.status}`, payload);
    const statusAlias = await checkClientStatus(payload, client.status);
    log('debug', `[processClient] Retrieved status alias: ${statusAlias}`, payload);
    const isBanned = statusAlias === 'banned';

    if (isBanned) {
      log('info', `[processClient] Client ID=${client.id} is banned. Updating status...`, payload);
      client = await payload.update({
        collection: 'clients',
        id: client.id,
        data: {
          enabled: "disabled",
        },
      });
      client.isBanned = true;
    } else {
      client.isBanned = false;
    }

    return client;
  } catch (error: any) {
    log('error', `[processClient] Error processing client: ${error.message}`, payload);
    return { total_visit: 1 };
  }
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/checkClientStatus.ts
// Version: 1.1.5-stable
//
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —á–∏—Å–ª–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–æ–ª–µ status.
// - –ï—Å–ª–∏ status —Ä–∞–≤–µ–Ω undefined –∏–ª–∏ null, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è "new" –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
// - –ï—Å–ª–∏ status ‚Äì –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º alias, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è alias; –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å ‚Äì —á–∏—Å–ª–æ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∑–∞–ø—Ä–æ—Å –∫ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "statuses".
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function checkClientStatus(
  payload: Payload,
  status: any
): Promise<string | null> {
  try {
    if (status === undefined || status === null) {
      log('debug', 'checkClientStatus: status is undefined or null, defaulting to "new"');
      return "new";
    }
    if (typeof status === 'object') {
      if ('alias' in status && typeof status.alias === 'string') {
        return status.alias;
      }
      if ('id' in status) {
        const statusResult = await payload.find({
          collection: 'statuses',
          where: { id: { equals: status.id } },
          limit: 1,
        });
        const statusDoc = statusResult.docs[0];
        return statusDoc?.alias || "new";
      }
    }
    if (typeof status === 'number' || typeof status === 'string') {
      const statusResult = await payload.find({
        collection: 'statuses',
        where: { id: { equals: status } },
        limit: 1,
      });
      const statusDoc = statusResult.docs[0];
      return statusDoc?.alias || "new";
    }
  } catch (error: any) {
    log('error', `‚ùå –û—à–∏–±–∫–∞ –≤ checkClientStatus: ${error.message}`, payload);
  }
  return "new";
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/bannedClient.ts
// Version: 1.2.3-stable
//
// [CHANGELOG]
// - –û–±—ä–µ–¥–∏–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–Ω–∞ –≤ –æ–¥–∏–Ω middleware.
// - –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Å–µ—Å—Å–∏–æ–Ω–Ω—ã–π —Ñ–ª–∞–≥ isBanned; –µ—Å–ª–∏ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –¥–∞–ª—å–Ω–µ–π—à–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è.
// - –ï—Å–ª–∏ —Ñ–ª–∞–≥ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ checkClientStatus.
// - –ï—Å–ª–∏ alias —Ä–∞–≤–µ–Ω "banned", –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Ñ–ª–∞–≥ isBanned —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ —Å–µ—Å—Å–∏–∏.
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Context } from 'grammy';
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

export function bannedClientHook(payload: Payload) {
  return async (ctx: Context & { session: any }, next: () => Promise<void>): Promise<void> => {
    try {
      if (ctx.session.isBanned) {
        await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
        log('info', 'bannedClientHook: Session indicates client is banned, skipping processing.', payload);
        return;
      }
      if (ctx.from) {
        const telegramId = ctx.from.id;
        const { docs } = await payload.find({
          collection: 'clients',
          where: { telegram_id: { equals: telegramId } },
          limit: 1,
        });
        const client = docs.length > 0 ? docs[0] : null;
        if (client && client.status) {
          const statusAlias = await checkClientStatus(payload, client.status);
          if (statusAlias === 'banned') {
            await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
            log('info', `bannedClientHook: Client ID=${client.id} is banned according to DB check.`, payload);
            ctx.session.isBanned = true;
            return;
          }
        }
      }
      await next();
    } catch (error: any) {
      log('error', `bannedClientHook: Error checking ban status: ${error.message}`, payload);
      await next();
    }
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock.ts
// Version: 1.3.6 (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏ TS18048)
// [CHANGELOG]
// - –ï—Å–ª–∏ aliasOverride –Ω–µ –∑–∞–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è botConfig.interface.defaultStartLayout.
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è botConfig.interface –∏ –µ—ë –ø–æ–ª—è blocks.
// - –ü–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä non‚Äënull assertion –¥–ª—è botConfig.interface.blocks.
// - –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–æ–≤ –æ—Å—Ç–∞—ë—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.

import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index';
import { handleButtonBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

interface LayoutBlock {
  clearPreviousMessages: boolean;
  name: string;
  blocks: Array<{
    blockType: string;
    description?: string;
    [key: string]: any;
  }>;
}

const blockHandlers: Record<string, (ctx: BotContext, block: any, payload: Payload) => Promise<void>> = {
  messageblock: processMessageBlock,
  'message-blocks': processMessageBlock,
  buttonblock: async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  'button-blocks': async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  catalogblock: renderCatalogBlock,
  'catalog-blocks': renderCatalogBlock,
};

export async function sendLayoutBlock(
  ctx: BotContext,
  botConfig: any, // –û–∂–∏–¥–∞–µ—Ç—Å—è –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ BotConfig
  payload: Payload,
  aliasOverride?: string
): Promise<void> {
  // –ï—Å–ª–∏ aliasOverride –Ω–µ –∑–∞–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ botConfig.interface.defaultStartLayout
  const layoutAlias = aliasOverride ?? botConfig.interface?.defaultStartLayout;

  if (!layoutAlias) {
    await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
    return;
  }

  try {
    log('debug', `–ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π layoutAlias: ${layoutAlias}`);
    log('debug', `BotConfig.interface: ${JSON.stringify(botConfig.interface)}`);

    // –ï—Å–ª–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –±–ª–æ–∫–æ–≤ –Ω–µ—Ç ‚Äì –≤—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º
    if (!botConfig.interface || !botConfig.interface.blocks || botConfig.interface.blocks.length === 0) {
      await ctx.reply(`Layout "${layoutAlias}" –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –±–ª–æ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      return;
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º non‚Äënull assertion, —Ç–∞–∫ –∫–∞–∫ –≤—ã—à–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ, —á—Ç–æ blocks –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –∏ –Ω–µ–ø—É—Å—Ç–æ–π
    const layoutBlock: LayoutBlock | undefined = botConfig.interface!.blocks.find(
      (block: any) => block.alias === layoutAlias
    );

    if (!layoutBlock) {
      const msg = await ctx.reply(`Layout "${layoutAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    if (layoutBlock.clearPreviousMessages && ctx.chat) {
      log('debug', `–ü–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π LayoutBlock "${layoutBlock.name}" –æ—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è.`);
      await clearPreviousMessages(ctx);
    }

    if (!Array.isArray(layoutBlock.blocks) || layoutBlock.blocks.length === 0) {
      const msg = await ctx.reply(`Layout "${layoutBlock.name}" –ø—É—Å—Ç. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    for (const block of layoutBlock.blocks) {
      try {
        const blockType = block.blockType?.toLowerCase();
        const handler = blockHandlers[blockType];
        if (handler) {
          log('debug', `–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–ª–æ–∫ —Ç–∏–ø–∞ "${blockType}"`);
          await handler(ctx, block, payload);
        } else {
          log('error', `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${blockType}`, payload);
          const msg = await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${block.blockType}`);
          storeMessageId(ctx, msg.message_id);
        }
      } catch (blockError) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–∞: ${(blockError as Error).message}`, payload);
        const msg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–ª–æ–∫–∞: ${layoutBlock.name}`);
        storeMessageId(ctx, msg.message_id);
      }
    }
  } catch (error: any) {
    log('error', `–û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞ "${layoutAlias}": ${(error as Error).message}`, payload);
    const errorMsg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞: "${layoutAlias}"`);
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/index.TelegramAPI.ts
// üìå –í–µ—Ä—Å–∏—è: 1.2.0
//
// [CHANGELOG]
// - –£–±—Ä–∞–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Ç–æ–≤–∞—Ä—ã –Ω–∞ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ `CatalogBlock`.
// - –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤—ã–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

/**
 * –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ `CatalogBlock`.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} block - –ë–ª–æ–∫ –∫–∞—Ç–∞–ª–æ–≥–∞.
 * @param {Payload} payload - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS.
 */
export async function renderCatalogBlock(ctx: BotContext, block: any, payload: Payload): Promise<void> {
  try {
    if (!block || !ctx.chat) {
      throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–ª–æ–∫ –∏–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞.');
    }

    const inlineKeyboard = new InlineKeyboard();

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } }, // –¢–æ–ª—å–∫–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
      limit: 999,
    });

    const categories = categoriesResult.docs;

    // –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç
    if (categories.length === 0) {
      await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row(); // –ù–æ–≤—ã–π —Ä—è–¥ –∫–∞–∂–¥—ã–µ 2 –∫–Ω–æ–ø–∫–∏
    });

    // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–±–ª–æ–∂–∫–æ–π –∏ –æ–ø–∏—Å–∞–Ω–∏–µ–º
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';

    await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });

    log('info', `–ö–∞—Ç–∞–ª–æ–≥ —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂—ë–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItems.ts
// Version: 1.4.10.1
//
// [CHANGELOG]
// - –§—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤–Ω–µ—à–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä clearMessages, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ—á–∏—â–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è.
// - –û—á–∏—Å—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –±–æ–ª—å—à–µ –Ω–µ –æ—Å–Ω–æ–≤–∞–Ω–∞ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ –Ω–æ–º–µ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏ –∞–∫—Ç–∏–≤–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏.
// - –õ–æ–≥–∏–∫–∞ –≤—ã–≤–æ–¥–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ —Ç–æ–≤–∞—Ä–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π –æ—Å—Ç–∞—ë—Ç—Å—è –ø—Ä–µ–∂–Ω–µ–π.
import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';

interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

export async function renderCategoryItems(
  ctx: BotContext,
  categoryId: string,
  options: RenderOptions,
  payload: Payload,
  clearMessages: boolean = true
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }
    // –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–ª–∞–≥–∞–µ–º—Å—è –Ω–∞ –≤–Ω–µ—à–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä clearMessages
    if (clearMessages) {
      await clearPreviousMessages(ctx);
    }
    const category = await payload.findByID({
      collection: 'product-categories',
      id: categoryId,
    });
    if (!category) {
      log('error', `–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å ID "${categoryId}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`, payload);
      const msg = await ctx.reply('–û—à–∏–±–∫–∞: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
      storeMessageId(ctx, msg.message_id);
      return;
    }
    const categoryMedia = Array.isArray(category.media) && category.media.length > 0
      ? category.media
      : [{ url: 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png' }];
    const categoryCaption = `<b>${category.name}</b>\n${category.description || ''}`;
    const categoryMsg = await ctx.replyWithPhoto(categoryMedia[0].url, {
      caption: categoryCaption,
      parse_mode: 'HTML',
    });
    storeMessageId(ctx, categoryMsg.message_id);

    let subcategories: any[] = [];
    let products: any[] = [];

    if (options.displayMode === 'subcategories' || options.displayMode === 'all') {
      const subResult = await payload.find({
        collection: 'product-categories',
        where: { parent_id: { equals: categoryId } },
        limit: 999,
      });
      subcategories = subResult.docs;
    }

    let totalPages = 0;
    if (options.displayMode === 'products' || options.displayMode === 'all') {
      const productPagination = await paginateCategoryItems(
        payload,
        'products',
        { category_ids: { in: [parseInt(categoryId, 10)] } },
        options.page,
        options.itemsPerPage
      );
      products = productPagination.docs;
      totalPages = productPagination.totalPages;
    }

    if (subcategories.length === 0 && products.length === 0) {
      const emptyMessage = await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –ø—É—Å—Ç–∞. –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.');
      storeMessageId(ctx, emptyMessage.message_id);
      return;
    }

    if (subcategories.length > 0 && (options.displayMode === 'subcategories' || options.displayMode === 'all')) {
      const subKeyboard = new InlineKeyboard();
      subcategories.forEach((subcat: any, index: number) => {
        subKeyboard.text(subcat.name, `catalogCategory|${subcat.id}`);
        if ((index + 1) % 2 === 0) subKeyboard.row();
      });
      const subMsg = await ctx.reply('–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏:', { reply_markup: subKeyboard });
      storeMessageId(ctx, subMsg.message_id);
    }

    if (products.length > 0 && (options.displayMode === 'products' || options.displayMode === 'all')) {
      for (const product of products) {
        await renderProductCard(ctx, product.id, payload);
      }
      // –ö–Ω–æ–ø–∫–∞ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë" –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –º–µ–Ω—å—à–µ –æ–±—â–µ–≥–æ —á–∏—Å–ª–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
      if (options.page < totalPages) {
        const navKeyboard = new InlineKeyboard().text(
          "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë",
          `catalogLoadMore|${categoryId}|${options.page + 1}|${options.itemsPerPage}`
        );
        const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${options.page}`, { reply_markup: navKeyboard });
        storeMessageId(ctx, navMsg.message_id);
      }
    }
    log('info', `–≠–ª–µ–º–µ–Ω—Ç—ã –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –¥–ª—è ID: ${categoryId}.`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: ${error.message}`, payload);
    const errorMsg = await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/paginateCategoryItems.ts
// Version: 1.1.2
//
// [CHANGELOG]
// - –§—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª—è–º–∏ docs –∏ totalPages –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–∞–Ω–∏—Ü.
import type { Payload, CollectionSlug } from 'payload';

export async function paginateCategoryItems(
  payload: Payload,
  collection: CollectionSlug,
  where: Record<string, any>,
  page: number,
  itemsPerPage: number,
): Promise<{ docs: any[]; totalPages: number }> {
  try {
    const result = await payload.find({
      collection,
      where,
      limit: itemsPerPage,
      page,
      sort: 'name',
    });
    return {
      docs: result.docs || [],
      totalPages: result.totalPages || Math.ceil((result.totalDocs || 0) / itemsPerPage),
    };
  } catch (error: any) {
    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}":`, error);
    throw new Error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}".`);
  }
}

export function generatePaginationData(
  currentPage: number,
  totalItems: number,
  itemsPerPage: number,
): {
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
} {
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  return {
    currentPage,
    totalPages,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItemsLoadMore.ts
// Version: 1.0.39
//
// [CHANGELOG]
// - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ paginateCategoryItems, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç totalPages.
// - –ï—Å–ª–∏ —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–∞–≤–Ω–∞ totalPages, –∫–Ω–æ–ø–∫–∞ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë" –Ω–µ –≤—ã–≤–æ–¥–∏—Ç—Å—è.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';

const DEMO_PRODUCT_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderCategoryItemsLoadMore(
  ctx: any,
  categoryId: string,
  payload: Payload,
  page: number,
  itemsPerPage: number = 3
): Promise<void> {
  try {
    log('info', `–ü–æ–¥–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä—ã –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${categoryId}, —Å—Ç—Ä–∞–Ω–∏—Ü–∞ ${page}, itemsPerPage=${itemsPerPage}`, payload);
    const productPagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = productPagination.docs;
    const totalPages = productPagination.totalPages;
    if (!products || products.length === 0) {
      const noMoreMsg = await ctx.reply("–ù–µ—Ç –±–æ–ª—å—à–µ —Ç–æ–≤–∞—Ä–æ–≤.", { parse_mode: 'HTML' });
      storeMessageId(ctx, noMoreMsg.message_id);
      log('info', `–¢–æ–≤–∞—Ä—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${categoryId}`, payload);
      return;
    }
    for (const product of products) {
      const productKeyboard = new InlineKeyboard()
        .text("–ü–æ–¥—Ä–æ–±–Ω–µ–µ", `catalogProductDetails|${product.id}`)
        .text("–ö—É–ø–∏—Ç—å", `catalogBuyNow|${product.id}`);
      const productMsg = await ctx.replyWithPhoto(DEMO_PRODUCT_IMAGE_URL, {
        caption: `<b>${product.name}</b>\n<b>–¶–µ–Ω–∞:</b> ${product.price ? `$${product.price}` : 'N/A'}\n<b>–°—Ç–∞—Ç—É—Å:</b> ${product.status ?? '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}`,
        parse_mode: 'HTML',
        reply_markup: productKeyboard,
      });
      storeMessageId(ctx, productMsg.message_id);
    }
    if (page < totalPages) {
      const navKeyboard = new InlineKeyboard()
        .text("–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë", `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`);
      const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${page}`, {
        parse_mode: 'HTML',
        reply_markup: navKeyboard,
      });
      storeMessageId(ctx, navMsg.message_id);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –≤ renderCategoryItemsLoadMore: ${error.message}`, payload);
    await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥—Ä—É–∑–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.");
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers.ts
// Version: 1.2.6
//
// [CHANGELOG]
// - –ò–∑–º–µ–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ callback‚Äë–¥–∞–Ω–Ω—ã—Ö.
// - –î–ª—è —Å–æ–±—ã—Ç–∏—è "catalogCategory" callback‚Äë–¥–∞–Ω–Ω—ã–µ —Ç–µ–ø–µ—Ä—å –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "catalogCategory|<categoryId>|<itemsPerPage>".
// - –î–ª—è —Å–æ–±—ã—Ç–∏—è "catalogLoadMore" callback‚Äë–¥–∞–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>".
// - –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ callback‚Äë–¥–∞–Ω–Ω—ã—Ö –∏ –ø–µ—Ä–µ–¥–∞—ë—Ç –∏—Ö –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { renderCategoryItems } from './renderCategoryItems';
import { renderCategoryItemsLoadMore } from './renderCategoryItemsLoadMore';

interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

export async function handleCatalogEvent(
  cbType: string,
  _unused: string, // –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—É–¥—É—Ç –∏–∑–≤–ª–µ—á–µ–Ω—ã –∏–∑ callback –¥–∞–Ω–Ω—ã—Ö
  _unused2: string | undefined,
  ctx: BotContext,
  payload: Payload,
): Promise<void> {
  try {
    if (!ctx.callbackQuery || !ctx.callbackQuery.data) {
      throw new Error('–î–∞–Ω–Ω—ã–µ callback –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
    }
    const parts = (ctx.callbackQuery.data as string).split('|');
    const eventType = parts[0]?.trim() ?? '';
    if (eventType === 'catalogCategory') {
      // –î–ª—è catalogCategory –æ–∂–∏–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç: "catalogCategory|<categoryId>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawItemsPerPage = parts[2]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: "${rawCategoryId}".`, payload);
        await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
        return;
      }
      const options: RenderOptions = {
        page: 1,
        itemsPerPage,
        displayMode: "all", // –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏, –µ—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è
      };
      // –ü—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤ –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –æ—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
      await renderCategoryItems(ctx, categoryId.toString(), options, payload, true);
    } else if (eventType === 'catalogLoadMore') {
      // –î–ª—è catalogLoadMore –æ–∂–∏–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawPageValue = parts[2]?.trim() ?? "1";
      const rawItemsPerPage = parts[3]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const nextPage = parseInt(rawPageValue, 10);
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: "${rawCategoryId}".`, payload);
        await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
        return;
      }
      const options: RenderOptions = {
        page: nextPage,
        itemsPerPage,
        displayMode: "all",
      };
      // –ü—Ä–∏ –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–µ –Ω–µ –æ—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
      await renderCategoryItemsLoadMore(ctx, categoryId.toString(), payload, nextPage, itemsPerPage);
    } else {
      await ctx.reply('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞.');
      log('error', `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞: ${eventType}`, payload);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞: ${error.message}`, payload);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–±—ã—Ç–∏—è.');
  }
}
// Path: src/blocks/TelegramAPI/CatalogBlock/renderCatalogBlock.ts
// Version: 1.4.2
//
// [CHANGELOG]
// - –ò–∑–º–µ–Ω—ë–Ω —Ñ–æ—Ä–º–∞—Ç callback‚Äë–¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ itemsPerPage –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–ª–æ–∫–∞.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderCatalogBlock(
  ctx: BotContext,
  block: any,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }

    // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } },
      limit: 999,
    });
    const categories = categoriesResult.docs;
    if (categories.length === 0) {
      const emptyMsg = await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      storeMessageId(ctx, emptyMsg.message_id);
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }
    const inlineKeyboard = new InlineKeyboard();
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ itemsPerPage –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–ª–æ–∫–∞ (–µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äì –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3)
    const itemsPerPage = block.itemsPerPage ?? 3;
    // –§–æ—Ä–º–∏—Ä—É–µ–º callback –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "catalogCategory|<categoryId>|<itemsPerPage>"
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}|${itemsPerPage}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row();
    });
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';
    const catalogMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });
    storeMessageId(ctx, catalogMsg.message_id);
    log('info', `–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ CatalogBlock —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    const errorMsg = await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
    if (errorMsg?.message_id) {
      storeMessageId(ctx, errorMsg.message_id);
    }
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductCard.ts
// Version: 1.0.12
//
// [CHANGELOG]
// - –£–¥–∞–ª—ë–Ω –≤—ã–∑–æ–≤ clearPreviousMessages(ctx), —á—Ç–æ–±—ã –Ω–µ —É–¥–∞–ª—è—Ç—å —É–∂–µ –≤—ã–≤–µ–¥–µ–Ω–Ω—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞ –ø—Ä–∏ –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ–π –ø–æ–¥–≥—Ä—É–∑–∫–µ.
// - –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ–¥—É–∫—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import {
  storeMessageId,
  BotContext,
} from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductCard(
  ctx: BotContext,
  productId: string,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const msg = await ctx.reply("–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", { parse_mode: 'HTML' });
      storeMessageId(ctx, msg.message_id);
      log('error', `–ü—Ä–æ–¥—É–∫—Ç —Å ID ${productId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`, payload);
      return;
    }
    const { name, price, description } = product as any;
    let messageText = `<b>${name}</b>\n<b>–¶–µ–Ω–∞:</b> $${price}\n`;
    messageText += `<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> ${description || '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è'}\n`;
    const keyboard = new InlineKeyboard()
      .text("–ù–∞–∑–∞–¥", `catalogBack|${productId}`)
      .text("–ó–∞–∫–∞–∑–∞—Ç—å", `order|${productId}`);
    const cardMsg = await ctx.replyWithPhoto(DEMO_IMAGE_URL, {
      caption: messageText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
    storeMessageId(ctx, cardMsg.message_id);
    log('info', `–ö–∞—Ä—Ç–æ—á–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∞ —Å ID ${productId} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –ø—Ä–æ–¥—É–∫—Ç–∞: ${error.message}`, payload);
    await ctx.reply(
      "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–¥—É–∫—Ç–µ.",
      { parse_mode: 'HTML' }
    );
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock.ts
// üìå –í–µ—Ä—Å–∏—è: 1.1.2
//
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ ID –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (—Å –∫–Ω–æ–ø–∫–∞–º–∏) –≤ `previousMessages`.
// - –£–ª—É—á—à–µ–Ω–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–Ω–æ–ø–æ–∫ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π.
// - –û–±–µ—Å–ø–µ—á–µ–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è.

import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} buttonBlock - –û–±—ä–µ–∫—Ç –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {string} [defaultDescription] - –û–ø–∏—Å–∞–Ω–∏–µ –±–ª–æ–∫–∞ –∫–Ω–æ–ø–æ–∫, –µ—Å–ª–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –∑–∞–¥–∞–Ω–æ –≤ buttonBlock.
 */
export async function handleButtonBlock(
  ctx: BotContext,
  buttonBlock: any,
  defaultDescription = '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:'
): Promise<void> {
  if (!ctx.chat) {
    log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', undefined);
    return;
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∫–Ω–æ–ø–æ–∫
  if (!Array.isArray(buttonBlock.buttons) || buttonBlock.buttons.length === 0) {
    log('error', '–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–Ω–æ–ø–æ–∫.', undefined);
    const emptyMsg = await ctx.reply('–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –ø—É—Å—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–Ω–æ–ø–∫–∏.');
    storeMessageId(ctx, emptyMsg.message_id); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –µ–≥–æ –º–æ–∂–Ω–æ –±—ã–ª–æ —É–¥–∞–ª–∏—Ç—å
    return;
  }

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑ buttonBlock –∏–ª–∏ fallback –Ω–∞ defaultDescription
  const description = buttonBlock.description || defaultDescription;

  const inlineKeyboard = new InlineKeyboard();

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
  buttonBlock.buttons.forEach((btn: any) => {
    try {
      const callbackData = btn.callback_data || '';
      const buttonText = btn.text;

      switch (btn.callbackType) {
        case 'layout':
        case 'message':
        case 'command':
          inlineKeyboard.text(buttonText, `${btn.callbackType}|${callbackData}`);
          break;
        case 'link':
          inlineKeyboard.url(buttonText, btn.url || '');
          break;
        default:
          inlineKeyboard.text(buttonText, callbackData);
      }

      if (btn.newRow) {
        inlineKeyboard.row();
      }
    } catch (error: any) {
      log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–Ω–æ–ø–∫–∏: ${error.message}`, undefined);
    }
  });

  // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–Ω–æ–ø–æ–∫
  try {
    const buttonMsg = await ctx.reply(description, { reply_markup: inlineKeyboard });
    storeMessageId(ctx, buttonMsg.message_id); // –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    log('info', `–ö–Ω–æ–ø–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã. –°–æ–æ–±—â–µ–Ω–∏–µ ID: ${buttonMsg.message_id}`, undefined);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–Ω–æ–ø–æ–∫: ${error.message}`, undefined);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index.TelegramAPI.ts
// Version: 1.0.9
//
// This utility processes a MessageBlock by sending its content using HTML formatting via grammY.
// For testing purposes, if a media file is attached, instead of using the media URL from the payload,
// a fixed URL is used:
//   https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg
// This is only for testing and should be removed or disabled in production.
// It uses standard Payload CMS v3 type definitions and grammY's Context type with session support.

import type { Context, SessionFlavor } from 'grammy';

interface SessionData {
  previousMessages: number[];
}

type BotContext = Context & SessionFlavor<SessionData>;

/**
 * For testing purposes, returns a fixed media URL.
 * In production, use getAbsoluteMediaUrl to compute the absolute URL.
 *
 * @param url - The media file URL (unused in testing).
 * @returns The fixed test media URL.
 */
function getTestMediaUrl(url: string): string {
  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ URL
  console.log(`[DEBUG] Overriding media URL for testing. Original URL: "${url}"`);
  return "https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg";
}

export async function processMessageBlock(ctx: BotContext, blockData: any): Promise<void> {
  if (!ctx.chat) return;

  // Retrieve the text from the block. The text should already contain valid HTML formatting.
  const text: string = blockData.text || '';

  try {
    let sentMsg;
    // –ï—Å–ª–∏ –ø–æ–ª–µ media –∑–∞–¥–∞–Ω–æ –∏ –Ω–µ –ø—É—Å—Ç–æ–µ, –¥–ª—è —Ç–µ—Å—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π URL.
    if (blockData.media && typeof blockData.media.url === 'string' && blockData.media.url.trim() !== "") {
      const mediaUrl = getTestMediaUrl(blockData.media.url);
      console.log(`[DEBUG] blockData.media:`);
      console.dir(blockData.media, { depth: null });
      console.log(`[DEBUG] Sending photo with test URL: "${mediaUrl}" and caption: "${text}"`);
      sentMsg = await ctx.replyWithPhoto(mediaUrl, {
        caption: text,
        parse_mode: 'HTML'
      });
    } else {
      sentMsg = await ctx.reply(text, { parse_mode: 'HTML' });
    }
    if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
      ctx.session.previousMessages.push(sentMsg.message_id);
      console.log(`[DEBUG] Stored message ID: ${sentMsg.message_id}. Current previousMessages: ${ctx.session.previousMessages}`);
    }
  } catch (error: any) {
    console.error('Error processing MessageBlock:', error);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/initializeBots.ts
// Version: 1.4.2-stable+goBack_final_fix
//
// [CHANGELOG]
// - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ BotConfig –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–æ–≤.
// - –§—É–Ω–∫—Ü–∏—è createUnifiedBotConfig –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç rawBotData.interface –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω–æ–µ —Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.
// - –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start: –ø–æ—Å–ª–µ processClient –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è layout alias –Ω–∞ –æ—Å–Ω–æ–≤–µ total_visit –∫–ª–∏–µ–Ω—Ç–∞ (–µ—Å–ª–∏ total_visit === 1 ‚Äì –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è defaultFirstVisitLayout, –∏–Ω–∞—á–µ defaultStartLayout).
// - Middleware bannedClientHook –ø–æ–¥–∫–ª—é—á—ë–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞.
// - –í callback‚Äë–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤–µ—Ç–∫–∏ –¥–ª—è —Ç–∏–ø–æ–≤ "catalogCategory" –∏ "catalogLoadMore" –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π,
//   –∞ —Ç–∞–∫–∂–µ ‚Äì –µ—Å–ª–∏ callback —Å —Ç–∏–ø–æ–º "layout" –∏–º–µ–µ—Ç alias "go_back_state", –æ–Ω –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –≤ goBackState.
// - –ú–µ—Ö–∞–Ω–∏–∑–º go_back_state —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —á–µ—Ä–µ–∑ –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ goBackState.
// - –¢–∏–ø BotContext —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∏–∑ –º–æ–¥—É–ª—è clearPreviousMessages.
import type { Payload } from 'payload';
import type { Config, Plugin } from 'payload';
import { Bot as TelegramBot, session } from 'grammy';

import { bannedClientHook } from '@/plugins/TelegramAPI/utils/ClientUtils/bannedClient';
import { processClient } from '@/plugins/TelegramAPI/utils/ClientUtils/processClient';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { handleCatalogEvent } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';
import { goBackState } from '@/plugins/TelegramAPI/utils/SystemUtils/goBackState';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–æ–≤ —Å–µ—Å—Å–∏–∏ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è —É–Ω–∏—Ñ–∏–∫–∞—Ü–∏–∏
import type { BotContext, SessionData } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

export type { BotContext };

export interface UnifiedBotInterface {
  blocks: any[];
  defaultStartLayout: string;
  defaultFirstVisitLayout: string;
  total_visit: number;
}

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/**
 * –û–±—ä–µ–¥–∏–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –±–æ—Ç–∞ (–∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ Bots)
 * –≤ –µ–¥–∏–Ω—ã–π –æ–±—ä–µ–∫—Ç –Ω–∞—Å—Ç—Ä–æ–µ–∫ (UnifiedBotConfig). –ï—Å–ª–∏ rawBotData.interface –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç,
 * –µ–≥–æ –ø–æ–ª—è –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è —Å –Ω–∞–±–æ—Ä–æ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π; –µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äì –ø–æ–¥—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
 */
export function createUnifiedBotConfig(rawBotData: any): UnifiedBotConfig {
  const defaultInterface: UnifiedBotInterface = {
    blocks: [],
    defaultStartLayout: 'start',
    defaultFirstVisitLayout: 'start_first_visit',
    total_visit: 0,
  };
  return {
    id: rawBotData.id,
    name: rawBotData.name,
    token: rawBotData.token,
    description: rawBotData.description,
    enabled: rawBotData.enabled,
    initialization_status: rawBotData.initialization_status,
    last_initialized: rawBotData.last_initialized,
    interface: {
      blocks: Array.isArray(rawBotData.interface?.blocks) ? rawBotData.interface.blocks : defaultInterface.blocks,
      defaultStartLayout: rawBotData.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: rawBotData.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof rawBotData.interface?.total_visit === 'number'
        ? rawBotData.interface.total_visit
        : defaultInterface.total_visit,
    },
  };
}

export async function initializeBots(payload: Payload): Promise<void> {
  try {
    log('info', '–ü–æ–∏—Å–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤...', payload);
    const { docs: bots } = await payload.find({
      collection: 'bots',
      where: { enabled: { equals: 'enabled' } },
      limit: 999,
    });
    log('info', `–ù–∞–π–¥–µ–Ω–æ ${bots.length} –±–æ—Ç–æ–≤ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.`, payload);

    for (const botData of bots) {
      const unifiedBotData = createUnifiedBotConfig(botData);
      const botConfig = new BotConfig(unifiedBotData);

      console.log('BotConfig:', JSON.stringify(botConfig, null, 2));
      await initBot(payload, botConfig);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–æ–≤: ${error.message}`, payload);
  }
}

async function initBot(payload: Payload, botConfig: BotConfig): Promise<void> {
  try {
    if (!botConfig.token) {
      log('error', `–ü—Ä–æ–ø—É—â–µ–Ω –±–æ—Ç "${botConfig.name}": –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω.`, payload);
      return;
    }
    const bot = new TelegramBot<BotContext>(botConfig.token);

    bot.use(
      session<SessionData, BotContext>({
        initial: () => ({ previousMessages: [], stateStack: [], previousState: undefined, isBanned: false }),
      })
    );

    bot.use(bannedClientHook(payload));

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start
    bot.command('start', async (ctx) => {
      try {
        log('info', `–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}.`, payload);
        const telegramId = ctx.from?.id;
        if (!telegramId) {
          await ctx.reply('–û—à–∏–±–∫–∞: Telegram ID –Ω–µ –Ω–∞–π–¥–µ–Ω.');
          return;
        }
        const client = await processClient(payload, telegramId, botConfig.id, {
          first_name: ctx.from?.first_name,
          last_name: ctx.from?.last_name,
          username: ctx.from?.username,
        });
        ctx.session.isBanned = client.isBanned;
        if (!client.isBanned) {
          const layoutAlias = client.total_visit === 1
            ? botConfig.interface.defaultFirstVisitLayout
            : botConfig.interface.defaultStartLayout;
          log('info', `–í—ã–±—Ä–∞–Ω layoutAlias: ${layoutAlias} (client.total_visit=${client.total_visit})`, payload);
          if (layoutAlias) {
            const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === layoutAlias);
            if (layoutBlock) {
              // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞
              ctx.session.previousState = layoutBlock;
              await sendLayoutBlock(ctx, botConfig, payload, layoutAlias);
            } else {
              await ctx.reply(`–û—à–∏–±–∫–∞: –õ–µ–π–∞—É—Ç —Å alias "${layoutAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
            }
          } else {
            await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
          }
        } else {
          await ctx.reply('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.');
        }
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /start: ${error.message}`, payload);
      }
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ callback‚Äë–∑–∞–ø—Ä–æ—Å–æ–≤
    bot.on('callback_query:data', async (ctx) => {
      if (!ctx.callbackQuery || !ctx.callbackQuery.data) return;
      try {
        const data = ctx.callbackQuery.data;
        const parts = data.split('|');
        const cbType = parts[0]?.trim() ?? '';
        const callbackAlias = parts[1]?.trim() ?? '';

        // –ï—Å–ª–∏ callback —Ç–∏–ø–∞ "layout" –∏ alias —Ä–∞–≤–µ–Ω "go_back_state", –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –≤ goBackState
        if (cbType === 'layout' && callbackAlias === 'go_back_state') {
          await goBackState(ctx, payload, botConfig);
        }
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–∏–ø–æ–≤, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –∫–∞—Ç–∞–ª–æ–≥–æ–º
        else if (cbType === 'catalogCategory' || cbType === 'catalogLoadMore') {
          await handleCatalogEvent(cbType, callbackAlias, '', ctx, payload);
          log('info', `Callback "${cbType}|${callbackAlias}" –æ–±—Ä–∞–±–æ—Ç–∞–Ω —á–µ—Ä–µ–∑ handleCatalogEvent.`, payload);
        }
        else {
          switch (cbType) {
            case 'layout': {
              const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === callbackAlias);
              if (layoutBlock) {
                ctx.session.previousState = layoutBlock;
                await sendLayoutBlock(ctx, botConfig, payload, callbackAlias);
              } else {
                await ctx.reply(`–û—à–∏–±–∫–∞: –õ–µ–π–∞—É—Ç —Å alias "${callbackAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
              }
              break;
            }
            case 'message': {
              await processMessageBlock(ctx, { message: callbackAlias });
              log('info', `MessageBlock "${callbackAlias}" —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.`, payload);
              break;
            }
            case 'command': {
              if (callbackAlias === 'go_back_state') {
                await goBackState(ctx, payload, botConfig);
              } else {
                await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${callbackAlias}`);
              }
              break;
            }
            default: {
              await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø callback: ${cbType}`);
            }
          }
        }
        await ctx.answerCallbackQuery();
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback_query: ${error.message}`, payload);
      }
    });

    bot.start();
    log('info', `ü§ñ –ë–æ—Ç "${botConfig.name}" —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.`, payload);

    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: {
        initialization_status: 'Initialized',
        last_initialized: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞ "${botConfig.name}": ${error.message}`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: { initialization_status: 'Error' },
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/BotConfig.ts
// Version: 1.4.0-stable+goBack_fix
//
// [CHANGELOG]
// - –û–±–Ω–æ–≤–ª—ë–Ω –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ –Ω–∞–ª–∏—á–∏—è —Å–≤–æ–π—Å—Ç–≤–∞ interface —Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.
import type { UnifiedBotConfig, UnifiedBotInterface } from './initializeBots';

const defaultInterface: UnifiedBotInterface = {
  blocks: [],
  defaultStartLayout: 'start',
  defaultFirstVisitLayout: 'start_first_visit',
  total_visit: 0,
};

export class BotConfig {
  public id: number;
  public name: string;
  public token: string;
  public description?: string;
  public enabled: string;
  public initialization_status: string;
  public last_initialized?: string;
  public interface: UnifiedBotInterface;

  constructor(data: UnifiedBotConfig) {
    this.id = data.id;
    this.name = data.name;
    this.token = data.token;
    this.description = data.description;
    this.enabled = data.enabled;
    this.initialization_status = data.initialization_status;
    this.last_initialized = data.last_initialized;
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    this.interface = {
      blocks: data.interface?.blocks ?? defaultInterface.blocks,
      defaultStartLayout: data.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: data.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit:
        typeof data.interface?.total_visit === 'number'
          ? data.interface.total_visit
          : defaultInterface.total_visit,
    };
  }

  get telegramApiToken(): string {
    return this.token;
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/goBackState.ts
// Version: 1.0.2-goBack_fix
//
// [CHANGELOG]
// - –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏—è "–Ω–∞–∑–∞–¥" —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–æ–ª—è previousState –∏–∑ —Å–µ—Å—Å–∏–∏.
// - –ï—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ, –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è sendLayoutBlock —Å alias –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
// - –ï—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–µ—Ç, –≤—ã–≤–æ–¥–∏—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ.
import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';

export async function goBackState(ctx: BotContext, payload: Payload, botConfig: any): Promise<void> {
    try {
        if (!ctx.session.previousState) {
            await ctx.reply('–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
            return;
        }
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º alias –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        const previousAlias = ctx.session.previousState.alias;
        await sendLayoutBlock(ctx, botConfig, payload, previousAlias);
        log('info', '–ö–æ–º–∞–Ω–¥–∞ go_back_state –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–æ–∑–≤—Ä–∞—â—ë–Ω –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.', payload);
    } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã go_back_state: ${error.message}`, payload);
        await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.');
    }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages.ts
// Version: 1.3.5-goBack_fix
//
// [CHANGELOG]
// - –û–±–Ω–æ–≤–ª—ë–Ω —Ç–∏–ø SessionData: –¥–æ–±–∞–≤–ª–µ–Ω—ã stateStack, previousState –∏ isBanned –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ go_back_state.
import type { Context, SessionFlavor } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export interface SessionData {
  previousMessages: number[];
  stateStack: any[];
  previousState?: any;
  isBanned: boolean;
}

export type BotContext = Context & SessionFlavor<SessionData>;

export async function clearPreviousMessages(ctx: BotContext): Promise<void> {
  if (!ctx.chat || !ctx.session || !Array.isArray(ctx.session.previousMessages)) {
    log('debug', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.');
    return;
  }
  const chatId = ctx.chat.id;
  const messageIds = ctx.session.previousMessages;
  try {
    for (const msgId of messageIds) {
      try {
        await ctx.api.editMessageReplyMarkup(chatId, msgId, { reply_markup: undefined });
      } catch (error: any) {}
      try {
        await ctx.api.deleteMessage(chatId, msgId);
      } catch (error: any) {}
    }
  } catch (err: any) {
  } finally {
    ctx.session.previousMessages = [];
  }
}

export function storeMessageId(ctx: BotContext, messageId: number): void {
  if (!messageId) return;
  if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
    ctx.session.previousMessages.push(messageId);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/SystemUtils/Logger.ts
// üìå –í–µ—Ä—Å–∏—è: 1.1.0
//
// [CHANGELOG]
// - –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–º–ø–æ—Ä—Ç `Payload` –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
// - –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ `Payload`.
// - –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ –±–ª–æ–∫–µ Payload CMS –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.

import type { Payload } from 'payload';

/**
 * –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {string} level - –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ('info', 'debug', 'error').
 * @param {string} message - –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {Payload} [payload] - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞.
 * @param {Record<string, any>} [context] - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–±—ä–µ–∫—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞).
 */
export function log(
  level: 'info' | 'debug' | 'error',
  message: string,
  payload?: Payload,
  context?: Record<string, any>
): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

  // –í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
  if (context && Object.keys(context).length > 0) {
    console.log(logMessage, context);
  } else {
    console.log(logMessage);
  }

  // –í—ã–≤–æ–¥ —á–µ—Ä–µ–∑ Payload CMS, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ
  if (payload?.logger && typeof payload.logger[level] === 'function') {
    try {
      payload.logger[level](message, context || {});
    } catch (err: any) {
      console.error(
        `[${timestamp}] [ERROR] –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ Payload CMS: ${err.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`
      );
    }
  }
}
// Path: src/plugins/TelegramAPI/types/TelegramBlocksTypes.ts
// Version: 1.1.3
export enum BlockType {
  Layout = 'layout-blocks',
  Catalog = 'catalog-blocks',
  Message = 'message-blocks',
  Button = 'button-blocks',
  Command = 'command-blocks',
}

export interface TelegramLayoutBlock {
  blockType: BlockType.Layout;
  name: string;
  alias: string;
  blocks: TelegramSubBlock[];
  clearPreviousMessages?: boolean;
}

export interface TelegramCatalogBlock {
  blockType: BlockType.Catalog;
  name: string;
  alias: string;
  itemsPerPage?: number;
}

export interface TelegramMessageBlock {
  blockType: BlockType.Message;
  text: string;
}

export interface TelegramButtonBlock {
  blockType: BlockType.Button;
  text: string;
  callbackType: 'link' | 'message' | 'layout' | 'command';
}

export interface TelegramCommandBlock {
  blockType: BlockType.Command;
  command: string;
  responseText: string;
}

export type TelegramSubBlock =
  | TelegramLayoutBlock
  | TelegramCatalogBlock
  | TelegramMessageBlock
  | TelegramButtonBlock
  | TelegramCommandBlock;
