Код в этом сообщении - считается СТАБИЛЬНОЙ-РАБОЧЕЙ версией, мы будем её дорабатывать без потери функционал. 

нам нужно продумать как обезопасить плагин при входящих сообщениях, попыток испольнить код или провести sql иньекцию:
1. При получении сообщения от пользователя выводим ему сообщение об игнорировнии ботом входящих сообщений
2. Реально не принимать и не обрабывать сообщения пользователя
3. Не выводить в диалоге бота или сразу удалять их, отправляя оповещение об игнорировании
4. создать фильтры безопастности, для защиты от атак.
5. предложить решение по автоматическому формированию реестра зарегистрированных команд на основе блоков и их колбэков.

(информация из интернета, требует проверки: 
1. Автоматическое удаление сообщений пользователя
Бот может быть запрограммирован на немедленное удаление входящих сообщений после их обработки. Для этого используется метод deleteMessage из Telegram Bot API.

Как реализовать:

Настройте бота на прослушивание входящих сообщений.

Для каждого полученного сообщения вызовите deleteMessage, передав chat_id и message_id 13.

Важно: Бот должен иметь права на удаление сообщений в чате. В личном диалоге с пользователем это разрешено по умолчанию. )

Предложи решение. 


-------------------------

ИНСТРУКЦИИ. ЗАПОМНИ - ВАЖНО!
1. Всегда указывай пути до файлов
2. Подробные комментраии в коде
3. Помни всю историю диалога
4. Запомянай все ошибки и решения к ним.
5. В коментариях кода первая строка путь до файла от корня. 
6. Каждый файл помечай коментами версия редактирования
7. иструкия по шагам.
8. Завай уточняющие вопросы, запомянай ответы на них
9. Отвечай всегда по русски
10. Не удаляй уже реализованный функционал, мы дорабатываем и рефакторим без потери функционала
11. Места редактирования кода помечаем комментариями
12. проставляем TODO там где это небоходимо.
13. Анализируй код файлов в связке, не допускай дублирования логики и функционала.
14. Придерживайся стандартов Payloadcms 3 и grammyjs

Запомни эти инструкции и чётко следуй им при выполнении заданий.
Зарание благодарю!

-------------------------

// Path: src/plugins/TelegramAPI/index.TelegramAPI.ts
// Version: 5.7.0
// Рефакторинг: Используется единая логика инициализации ботов из файла initializeBots.ts.
// Коллекции Bots и Clients регистрируются в плагине.
import type { Payload, Config, Plugin } from 'payload';
import Bots from '@/collections/TelegramAPI/Bots';
import Clients from '@/collections/TelegramAPI/Clients';
import { initializeBots } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const TelegramAPIPlugin: Plugin = (incomingConfig: Config): Config => {
  return {
    ...incomingConfig,
    collections: [
      ...(incomingConfig.collections || []),
      Bots,
      Clients,
    ],
    onInit: async (payload: Payload) => {
      log('info', 'TelegramAPIPlugin initialization started.', payload);
      await initializeBots(payload);
      log('info', 'TelegramAPIPlugin initialized successfully.', payload);
    },
  };
};

export default TelegramAPIPlugin;
// Path: src/plugins/TelegramAPI/utils/ClientUtils/processClient.ts
// Version: 1.3.9-refactored
// Рефакторинг: Удалено локальное объявление типа FromData, импортирован из общего файла TelegramBlocksTypes.ts.
// Поля telegramId и botId передаются отдельно, так как они не являются частью данных профиля Telegram.

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';
// Импорт типа FromData из общего файла с типами
import type { FromData } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function processClient(
  payload: Payload,
  telegramId: number,
  botId: number,
  fromData: FromData
): Promise<any> {
  try {
    log('info', `[processClient] Searching for client with telegram_id=${telegramId} and bot=${botId}`, payload);

    const { docs } = await payload.find({
      collection: 'clients',
      where: { telegram_id: { equals: telegramId } },
      limit: 1,
    });

    let client: any;

    if (!docs || docs.length === 0) {
      log('info', "[processClient] No existing client found, creating a new one...", payload);
      client = await payload.create({
        collection: 'clients',
        data: {
          telegram_id: telegramId,                   // Уникальный идентификатор пользователя Telegram
          bots: [botId],                             // Идентификатор бота
          first_name: fromData.first_name ?? "",
          last_name: fromData.last_name ?? "",
          user_name: fromData.username || 'anonymous_user',
          total_visit: 1,                            // Первое посещение
          last_visit: new Date().toISOString(),      // Текущая дата как дата последнего визита
          enabled: "enabled"
          // Поле status не передаётся, чтобы его значение установилось через defaultValue или beforeChange-хук в коллекции.
        },
      });
    } else {
      const existingClient = docs[0]!;
      log('info', `[processClient] Client found: ID=${existingClient.id}`, payload);
      let botsArray: any[] = Array.isArray(existingClient.bots)
        ? existingClient.bots
        : existingClient.bots ? [existingClient.bots] : [];
      if (!botsArray.some(b =>
        b != null && typeof b === 'object'
          ? b.id !== undefined && b.id.toString() === botId.toString()
          : b != null && b.toString() === botId.toString()
      )) {
        botsArray.push(botId);
        log('info', `[processClient] Bot ${botId} added to client ${existingClient.id}`, payload);
      }
      client = await payload.update({
        collection: 'clients',
        id: existingClient.id,
        data: {
          bots: botsArray,
          first_name: fromData.first_name ?? existingClient.first_name ?? "",
          last_name: fromData.last_name ?? existingClient.last_name ?? "",
          user_name: fromData.username || existingClient.user_name || 'anonymous_user',
          last_visit: new Date().toISOString(),
          total_visit: (existingClient.total_visit ?? 0) + 1,
        },
      });
    }

    log('debug', `[processClient] Client status: ${client.status}`, payload);
    const statusAlias = await checkClientStatus(payload, client.status);
    log('debug', `[processClient] Retrieved status alias: ${statusAlias}`, payload);
    const isBanned = statusAlias === 'banned';

    if (isBanned) {
      log('info', `[processClient] Client ID=${client.id} is banned. Updating status...`, payload);
      client = await payload.update({
        collection: 'clients',
        id: client.id,
        data: {
          enabled: "disabled",
        },
      });
      client.isBanned = true;
    } else {
      client.isBanned = false;
    }

    return client;
  } catch (error: any) {
    log('error', `[processClient] Error processing client: ${error.message}`, payload);
    return { total_visit: 1 };
  }
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/checkClientStatus.ts
// Version: 1.1.5-stable
//
// [CHANGELOG]
// - Добавлена поддержка числовых значений в поле status.
// - Если status равен undefined или null, возвращается "new" как значение по умолчанию.
// - Если status – объект с полем alias, возвращается alias; если статус – число или строка, выполняется запрос к коллекции "statuses".
// - Используется единый логгер log для отладки.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function checkClientStatus(
  payload: Payload,
  status: any
): Promise<string | null> {
  try {
    if (status === undefined || status === null) {
      log('debug', 'checkClientStatus: status is undefined or null, defaulting to "new"');
      return "new";
    }
    if (typeof status === 'object') {
      if ('alias' in status && typeof status.alias === 'string') {
        return status.alias;
      }
      if ('id' in status) {
        const statusResult = await payload.find({
          collection: 'statuses',
          where: { id: { equals: status.id } },
          limit: 1,
        });
        const statusDoc = statusResult.docs[0];
        return statusDoc?.alias || "new";
      }
    }
    if (typeof status === 'number' || typeof status === 'string') {
      const statusResult = await payload.find({
        collection: 'statuses',
        where: { id: { equals: status } },
        limit: 1,
      });
      const statusDoc = statusResult.docs[0];
      return statusDoc?.alias || "new";
    }
  } catch (error: any) {
    log('error', `❌ Ошибка в checkClientStatus: ${error.message}`, payload);
  }
  return "new";
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/bannedClient.ts
// Version: 1.2.3-stable
//
// [CHANGELOG]
// - Объединена логика проверки бана в один middleware.
// - Сначала проверяется сессионный флаг isBanned; если он установлен, дальнейшая обработка прекращается.
// - Если флаг не установлен, выполняется проверка статуса клиента через checkClientStatus.
// - Если alias равен "banned", отправляется сообщение и флаг isBanned сохраняется в сессии.
// - Используется единый логгер log для отладки.
import type { Context } from 'grammy';
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

export function bannedClientHook(payload: Payload) {
  return async (ctx: Context & { session: any }, next: () => Promise<void>): Promise<void> => {
    try {
      if (ctx.session.isBanned) {
        await ctx.reply("💀 Your account is locked! 💀 \n\n🚷 You've been banned.");
        log('info', 'bannedClientHook: Session indicates client is banned, skipping processing.', payload);
        return;
      }
      if (ctx.from) {
        const telegramId = ctx.from.id;
        const { docs } = await payload.find({
          collection: 'clients',
          where: { telegram_id: { equals: telegramId } },
          limit: 1,
        });
        const client = docs.length > 0 ? docs[0] : null;
        if (client && client.status) {
          const statusAlias = await checkClientStatus(payload, client.status);
          if (statusAlias === 'banned') {
            await ctx.reply("💀 Your account is locked! 💀 \n\n🚷 You've been banned.");
            log('info', `bannedClientHook: Client ID=${client.id} is banned according to DB check.`, payload);
            ctx.session.isBanned = true;
            return;
          }
        }
      }
      await next();
    } catch (error: any) {
      log('error', `bannedClientHook: Error checking ban status: ${error.message}`, payload);
      await next();
    }
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock.ts
// Version: 1.3.8-refactored
// Рефакторинг: Использование общего типа TelegramLayoutBlock и BotContext из файла TelegramBlocksTypes.ts.
// Локальное объявление типа LayoutBlock удалено. Функционал обработки блоков остаётся без изменений.
// Добавлена логика сохранения текущего состояния в стек (stateStack) перед переключением на новый layout.

import type { Payload } from 'payload';
// Импорт типов из общего файла с типами
import type { BotContext, TelegramLayoutBlock } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
import { handleButtonBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const blockHandlers: Record<string, (ctx: BotContext, block: any, payload: Payload) => Promise<void>> = {
  messageblock: processMessageBlock,
  'message-blocks': processMessageBlock,
  buttonblock: async (ctx, block, payload) => {
    const description = block.description || 'Выберите действие:';
    await handleButtonBlock(ctx, block, description);
  },
  'button-blocks': async (ctx, block, payload) => {
    const description = block.description || 'Выберите действие:';
    await handleButtonBlock(ctx, block, description);
  },
  catalogblock: renderCatalogBlock,
  'catalog-blocks': renderCatalogBlock,
};

export async function sendLayoutBlock(
  ctx: BotContext,
  botConfig: any, // Ожидается объект типа BotConfig
  payload: Payload,
  aliasOverride?: string
): Promise<void> {
  // Если aliasOverride не задан, используем значение из botConfig.interface.defaultStartLayout
  const layoutAlias = aliasOverride ?? botConfig.interface?.defaultStartLayout;

  if (!layoutAlias) {
    await ctx.reply('Ошибка: Не удалось определить layout alias.');
    return;
  }

  try {
    log('debug', `Используемый layoutAlias: ${layoutAlias}`);
    log('debug', `BotConfig.interface: ${JSON.stringify(botConfig.interface)}`);

    // Если уже установлено текущее состояние и его alias отличается от нового, сохраняем его в стек
    if (ctx.session.currentState && ctx.session.currentState.alias !== layoutAlias) {
      ctx.session.stateStack.push(ctx.session.currentState);
    }

    // Если интерфейс отсутствует или блоков нет – выводим сообщение и завершаем
    if (!botConfig.interface || !botConfig.interface.blocks || botConfig.interface.blocks.length === 0) {
      await ctx.reply(`Layout "${layoutAlias}" не содержит блоков. Добавьте блоки.`);
      return;
    }

    // Используем общее определение типа TelegramLayoutBlock вместо локального LayoutBlock
    const layoutBlock: TelegramLayoutBlock | undefined = botConfig.interface!.blocks.find(
      (block: any) => block.alias === layoutAlias
    );

    if (!layoutBlock) {
      const msg = await ctx.reply(`Layout "${layoutAlias}" не найден. Добавьте блоки.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    // Обновляем текущее состояние
    ctx.session.currentState = layoutBlock;

    if (layoutBlock.clearPreviousMessages && ctx.chat) {
      log('debug', `Перед отправкой LayoutBlock "${layoutBlock.name}" очищаем предыдущие сообщения.`);
      await clearPreviousMessages(ctx);
    }

    if (!Array.isArray(layoutBlock.blocks) || layoutBlock.blocks.length === 0) {
      const msg = await ctx.reply(`Layout "${layoutBlock.name}" пуст. Добавьте блоки.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    for (const block of layoutBlock.blocks) {
      try {
        const blockType = block.blockType?.toLowerCase();
        const handler = blockHandlers[blockType];
        if (handler) {
          log('debug', `Обрабатываем блок типа "${blockType}"`);
          await handler(ctx, block, payload);
        } else {
          log('error', `Неизвестный тип блока: ${blockType}`, payload);
          const msg = await ctx.reply(`Неизвестный тип блока: ${block.blockType}`);
          storeMessageId(ctx, msg.message_id);
        }
      } catch (blockError) {
        log('error', `Ошибка обработки блока: ${(blockError as Error).message}`, payload);
        const msg = await ctx.reply(`Произошла ошибка при обработке блока: ${layoutBlock.name}`);
        storeMessageId(ctx, msg.message_id);
      }
    }
  } catch (error: any) {
    log('error', `Общая ошибка при обработке лейаута "${layoutAlias}": ${(error as Error).message}`, payload);
    const errorMsg = await ctx.reply(`Произошла ошибка при обработке лейаута: "${layoutAlias}"`);
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// 📌 Путь: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/index.TelegramAPI.ts
// 📌 Версия: 1.2.0
//
// [CHANGELOG]
// - Убрана попытка загружать подкатегории и товары на главной странице `CatalogBlock`.
// - Добавлено описание вывода только первого уровня категорий.
// - Добавлена обработка отсутствия категорий.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

/**
 * Отображение `CatalogBlock`.
 * @param {BotContext} ctx - Контекст Telegram бота.
 * @param {any} block - Блок каталога.
 * @param {Payload} payload - Экземпляр Payload CMS.
 */
export async function renderCatalogBlock(ctx: BotContext, block: any, payload: Payload): Promise<void> {
  try {
    if (!block || !ctx.chat) {
      throw new Error('Некорректный блок или контекст чата.');
    }

    const inlineKeyboard = new InlineKeyboard();

    // Загрузка категорий первого уровня
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } }, // Только категории верхнего уровня
      limit: 999,
    });

    const categories = categoriesResult.docs;

    // Если категории отсутствуют
    if (categories.length === 0) {
      await ctx.reply('Категории отсутствуют.');
      log('info', 'Категории для отображения отсутствуют.', payload);
      return;
    }

    // Генерация кнопок для категорий
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row(); // Новый ряд каждые 2 кнопки
    });

    // Отправка сообщения с обложкой и описанием
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || 'Пожалуйста, выберите категорию:';

    await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });

    log('info', `Каталог успешно отображён для пользователя ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `Ошибка отображения CatalogBlock: ${error.message}`, payload);
    await ctx.reply('Произошла ошибка при загрузке каталога.');
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItems.ts
// Version: 1.4.12-refactored
//
// [CHANGELOG]
// - Добавлена опция protect_content во всех вызовах ctx.reply и ctx.replyWithPhoto,
//   чтобы при включенной защите контента сообщения, описания категорий, подкатегории и навигационные сообщения были защищены.
// - Остальная логика рендеринга категорий, подкатегорий и товаров с пагинацией остается прежней.

import type { Payload } from 'payload';
import type { BotContext, RenderOptions } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';

export async function renderCategoryItems(
  ctx: BotContext,
  categoryId: string,
  options: RenderOptions,
  payload: Payload,
  clearMessages: boolean = true
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }
    if (clearMessages) {
      await clearPreviousMessages(ctx);
    }
    const category = await payload.findByID({
      collection: 'product-categories',
      id: categoryId,
    });
    if (!category) {
      log('error', `Категория с ID "${categoryId}" не найдена.`, payload);
      const msg = await ctx.reply('Ошибка: категория не найдена.', {
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, msg.message_id);
      return;
    }
    const categoryMedia = Array.isArray(category.media) && category.media.length > 0
      ? category.media
      : [{ url: 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png' }];
    const categoryCaption = `<b>${category.name}</b>\n${category.description || ''}`;
    const categoryMsg = await ctx.replyWithPhoto(categoryMedia[0].url, {
      caption: categoryCaption,
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, categoryMsg.message_id);

    let subcategories: any[] = [];
    let products: any[] = [];

    if (options.displayMode === 'subcategories' || options.displayMode === 'all') {
      const subResult = await payload.find({
        collection: 'product-categories',
        where: { parent_id: { equals: categoryId } },
        limit: 999,
      });
      subcategories = subResult.docs;
    }

    let totalPages = 0;
    if (options.displayMode === 'products' || options.displayMode === 'all') {
      const productPagination = await paginateCategoryItems(
        payload,
        'products',
        { category_ids: { in: [parseInt(categoryId, 10)] } },
        options.page,
        options.itemsPerPage
      );
      products = productPagination.docs;
      totalPages = productPagination.totalPages;
    }

    if (subcategories.length === 0 && products.length === 0) {
      const emptyMessage = await ctx.reply('Категория пуста. Нет данных для отображения.', {
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, emptyMessage.message_id);
      return;
    }

    if (subcategories.length > 0 && (options.displayMode === 'subcategories' || options.displayMode === 'all')) {
      const subKeyboard = new InlineKeyboard();
      subcategories.forEach((subcat: any, index: number) => {
        subKeyboard.text(subcat.name, `catalogCategory|${subcat.id}`);
        if ((index + 1) % 2 === 0) subKeyboard.row();
      });
      const subMsg = await ctx.reply('Подкатегории:', {
        reply_markup: subKeyboard,
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, subMsg.message_id);
    }

    if (products.length > 0 && (options.displayMode === 'products' || options.displayMode === 'all')) {
      for (const product of products) {
        await renderProductCard(ctx, product.id, payload);
      }
      if (options.page < totalPages) {
        const navKeyboard = new InlineKeyboard().text(
          "Загрузить ещё",
          `catalogLoadMore|${categoryId}|${options.page + 1}|${options.itemsPerPage}`
        );
        const navMsg = await ctx.reply(`Страница ${options.page}`, {
          parse_mode: 'HTML',
          reply_markup: navKeyboard,
          protect_content: ctx.session.botConfig?.protectContent || false,
        });
        storeMessageId(ctx, navMsg.message_id);
      }
    }
    log('info', `Элементы категории успешно отправлены для ID: ${categoryId}.`, payload);
  } catch (error: any) {
    log('error', `Ошибка при рендеринге элементов категории: ${error.message}`, payload);
    const errorMsg = await ctx.reply('Произошла ошибка при загрузке данных категории.', {
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/paginateCategoryItems.ts
// Version: 1.1.2
//
// [CHANGELOG]
// - Функция теперь возвращает объект с полями docs и totalPages для корректной проверки наличия следующих страниц.
import type { Payload, CollectionSlug } from 'payload';

export async function paginateCategoryItems(
  payload: Payload,
  collection: CollectionSlug,
  where: Record<string, any>,
  page: number,
  itemsPerPage: number,
): Promise<{ docs: any[]; totalPages: number }> {
  try {
    const result = await payload.find({
      collection,
      where,
      limit: itemsPerPage,
      page,
      sort: 'name',
    });
    return {
      docs: result.docs || [],
      totalPages: result.totalPages || Math.ceil((result.totalDocs || 0) / itemsPerPage),
    };
  } catch (error: any) {
    console.error(`Ошибка при пагинации коллекции "${collection}":`, error);
    throw new Error(`Ошибка при загрузке данных из коллекции "${collection}".`);
  }
}

export function generatePaginationData(
  currentPage: number,
  totalItems: number,
  itemsPerPage: number,
): {
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
} {
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  return {
    currentPage,
    totalPages,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItemsLoadMore.ts
// Version: 1.0.40-refactored
//
// [CHANGELOG]
// - Используется обновленная функция paginateCategoryItems, которая возвращает totalPages.
// - Если текущая страница равна totalPages, кнопка "Загрузить ещё" не выводится.
// - Добавлена опция protect_content во всех вызовах ctx.reply/ctx.replyWithPhoto.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

const DEMO_PRODUCT_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderCategoryItemsLoadMore(
  ctx: BotContext,
  categoryId: string,
  payload: Payload,
  page: number,
  itemsPerPage: number = 3
): Promise<void> {
  try {
    log('info', `Подгружаем товары для категории ${categoryId}, страница ${page}, itemsPerPage=${itemsPerPage}`, payload);
    const productPagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = productPagination.docs;
    const totalPages = productPagination.totalPages;
    if (!products || products.length === 0) {
      const noMoreMsg = await ctx.reply("Нет больше товаров.", {
        parse_mode: 'HTML',
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, noMoreMsg.message_id);
      log('info', `Товары закончились для категории ${categoryId}`, payload);
      return;
    }
    for (const product of products) {
      await renderProductCard(ctx, product.id, payload);
    }
    if (page < totalPages) {
      const navKeyboard = new InlineKeyboard().text(
        "Загрузить ещё",
        `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`
      );
      const navMsg = await ctx.reply(`Страница ${page}`, {
        parse_mode: 'HTML',
        reply_markup: navKeyboard,
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, navMsg.message_id);
    }
  } catch (error: any) {
    log('error', `Ошибка в renderCategoryItemsLoadMore: ${error.message}`, payload);
    await ctx.reply("Произошла ошибка при подгрузке товаров.", {
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers.ts
// Version: 1.2.7-refactored
// Рефакторинг: Обновлены импорты типов из общего файла TelegramBlocksTypes.ts.
// Локальное объявление типа RenderOptions удалено.

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
// Импорт типов из общего файла
import type { BotContext, RenderOptions } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { renderCategoryItems } from './renderCategoryItems';
import { renderCategoryItemsLoadMore } from './renderCategoryItemsLoadMore';

export async function handleCatalogEvent(
  cbType: string,
  _unused: string, // больше не используется, параметры будут извлечены из callback данных
  _unused2: string | undefined,
  ctx: BotContext,
  payload: Payload,
): Promise<void> {
  try {
    if (!ctx.callbackQuery || !ctx.callbackQuery.data) {
      throw new Error('Данные callback отсутствуют.');
    }
    const parts = (ctx.callbackQuery.data as string).split('|');
    const eventType = parts[0]?.trim() ?? '';
    if (eventType === 'catalogCategory') {
      // Для catalogCategory ожидаем формат: "catalogCategory|<categoryId>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawItemsPerPage = parts[2]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `Некорректный идентификатор категории: "${rawCategoryId}".`, payload);
        await ctx.reply('Ошибка: некорректный идентификатор категории.');
        return;
      }
      const options: RenderOptions = {
        page: 1,
        itemsPerPage,
        displayMode: "all", // здесь можно настроить динамически, если потребуется
      };
      // При переходе в новую категорию очищаем предыдущие сообщения
      await renderCategoryItems(ctx, categoryId.toString(), options, payload, true);
    } else if (eventType === 'catalogLoadMore') {
      // Для catalogLoadMore ожидаем формат: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawPageValue = parts[2]?.trim() ?? "1";
      const rawItemsPerPage = parts[3]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const nextPage = parseInt(rawPageValue, 10);
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `Некорректный идентификатор категории: "${rawCategoryId}".`, payload);
        await ctx.reply('Ошибка: некорректный идентификатор категории.');
        return;
      }
      const options: RenderOptions = {
        page: nextPage,
        itemsPerPage,
        displayMode: "all",
      };
      // При постраничной загрузке не очищаем сообщения
      await renderCategoryItemsLoadMore(ctx, categoryId.toString(), payload, nextPage, itemsPerPage);
    } else {
      await ctx.reply('Неизвестный тип события каталога.');
      log('error', `Неизвестный тип события каталога: ${eventType}`, payload);
    }
  } catch (error: any) {
    log('error', `Ошибка обработки события каталога: ${error.message}`, payload);
    await ctx.reply('Произошла ошибка при обработке события.');
  }
}
// Path: src/blocks/TelegramAPI/CatalogBlock/renderCatalogBlock.ts
// Version: 1.4.3-refactored
//
// [CHANGELOG]
// - Формат callback‑данных для кнопок категорий: "catalogCategory|<categoryId>|<itemsPerPage>".
// - Добавлена опция protect_content, если бот настроен на защиту контента.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderCatalogBlock(
  ctx: BotContext,
  block: any,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } },
      limit: 999,
    });
    const categories = categoriesResult.docs;
    if (categories.length === 0) {
      const emptyMsg = await ctx.reply('Категории отсутствуют.');
      storeMessageId(ctx, emptyMsg.message_id);
      log('info', 'Категории для отображения отсутствуют.', payload);
      return;
    }
    const inlineKeyboard = new InlineKeyboard();
    const itemsPerPage = block.itemsPerPage ?? 3;
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}|${itemsPerPage}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row();
    });
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || 'Пожалуйста, выберите категорию:';
    const catalogMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, catalogMsg.message_id);
    log('info', `Главная страница CatalogBlock успешно отображена для пользователя ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `Ошибка отображения CatalogBlock: ${error.message}`, payload);
    const errorMsg = await ctx.reply('Произошла ошибка при загрузке каталога.');
    if (errorMsg?.message_id) {
      storeMessageId(ctx, errorMsg.message_id);
    }
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductCard.ts
// Version: 1.0.13-refactored
//
// [CHANGELOG]
// - Удалён вызов clearPreviousMessages(ctx).
// - Добавлена опция protect_content в параметры отправки сообщения, если бот настроен на защиту контента.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductCard(
  ctx: BotContext,
  productId: string,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const msg = await ctx.reply("Продукт не найден.", {
        parse_mode: 'HTML',
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, msg.message_id);
      log('error', `Продукт с ID ${productId} не найден.`, payload);
      return;
    }
    const { name, price, description } = product as any;
    let messageText = `<b>${name}</b>\n<b>Цена:</b> $${price}\n`;
    messageText += `<b>Описание:</b> ${description || 'Нет описания'}\n`;
    const keyboard = new InlineKeyboard()
      .text("Назад", `catalogBack|${productId}`)
      .text("Заказать", `order|${productId}`);
    const cardMsg = await ctx.replyWithPhoto(DEMO_IMAGE_URL, {
      caption: messageText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, cardMsg.message_id);
    log('info', `Карточка продукта с ID ${productId} успешно отправлена.`, payload);
  } catch (error: any) {
    log('error', `Ошибка при отображении карточки продукта: ${error.message}`, payload);
    await ctx.reply("Произошла ошибка при загрузке информации о продукте.", {
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock.ts
// Version: 1.1.3-refactored
//
// [CHANGELOG]
// - Если поле description в ButtonBlock не заполнено, используется значение по умолчанию "ButtonBlock".
// - Если ButtonBlock используется отдельно, текст описания выводится как сообщение с кнопками.
// - Если ButtonBlock является дочерним блоком MessageBlock, утилита MessageBlock игнорирует описание.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

/**
 * Обработка кнопочного блока.
 * @param {BotContext} ctx - Контекст Telegram бота.
 * @param {any} buttonBlock - Объект кнопочного блока.
 * @param {string} [defaultDescription] - Описание блока кнопок, если поле description не задано в buttonBlock.
 */
export async function handleButtonBlock(
  ctx: BotContext,
  buttonBlock: any,
  defaultDescription = 'ButtonBlock'
): Promise<void> {
  if (!ctx.chat) {
    log('error', 'Контекст чата отсутствует.', undefined);
    return;
  }

  // Проверка наличия кнопок
  if (!Array.isArray(buttonBlock.buttons) || buttonBlock.buttons.length === 0) {
    log('error', 'Кнопочный блок не содержит кнопок.', undefined);
    const emptyMsg = await ctx.reply('Кнопочный блок пуст. Пожалуйста, настройте кнопки.');
    storeMessageId(ctx, emptyMsg.message_id);
    return;
  }

  // Используем описание из buttonBlock, если оно задано, иначе значение по умолчанию.
  const description = buttonBlock.description || defaultDescription;

  const inlineKeyboard = new InlineKeyboard();

  // Генерация кнопок
  buttonBlock.buttons.forEach((btn: any) => {
    try {
      const callbackData = btn.callback_data || '';
      const buttonText = btn.text;

      switch (btn.callbackType) {
        case 'layout':
        case 'message':
        case 'command':
          inlineKeyboard.text(buttonText, `${btn.callbackType}|${callbackData}`);
          break;
        case 'link':
          inlineKeyboard.url(buttonText, btn.url || '');
          break;
        default:
          inlineKeyboard.text(buttonText, callbackData);
      }

      if (btn.newRow) {
        inlineKeyboard.row();
      }
    } catch (error: any) {
      log('error', `Ошибка при генерации кнопки: ${error.message}`, undefined);
    }
  });

  // Отправка сообщения с кнопками
  try {
    const buttonMsg = await ctx.reply(description, { reply_markup: inlineKeyboard });
    storeMessageId(ctx, buttonMsg.message_id);
    log('info', `Кнопки успешно отправлены. Сообщение ID: ${buttonMsg.message_id}`, undefined);
  } catch (error: any) {
    log('error', `Ошибка отправки кнопок: ${error.message}`, undefined);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock.ts
// Version: 1.0.12-refactored
//
// This utility processes a MessageBlock by sending its content using HTML formatting via grammY.
// If a MessageBlock contains a "buttons" field (provided via ButtonBlock), the buttons are attached via an inline keyboard.
// Added option protect_content if the bot is configured to protect content.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';

function getTestMediaUrl(url: string): string {
  console.log(`[DEBUG] Overriding media URL for testing. Original URL: "${url}"`);
  return "https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg";
}

function buildInlineKeyboard(buttons: any[]): InlineKeyboard {
  const keyboard = new InlineKeyboard();
  buttons.forEach((btn: any) => {
    const callbackType = btn.callbackType && btn.callbackType.trim() !== '' ? btn.callbackType : 'layout';
    const callbackData = btn.callback_data || '';
    const data = `${callbackType}|${callbackData}`;
    if (callbackType === 'link' && btn.url) {
      keyboard.url(btn.text, btn.url);
    } else {
      keyboard.text(btn.text, data);
    }
    if (btn.newRow) {
      keyboard.row();
    }
  });
  return keyboard;
}

export async function processMessageBlock(ctx: BotContext, blockData: any): Promise<void> {
  if (!ctx.chat) return;
  const text: string = blockData.text;
  try {
    const replyOptions: any = {
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    };

    let buttonsArray: any[] = [];
    if (Array.isArray(blockData.buttons) && blockData.buttons.length > 0) {
      if (blockData.buttons[0]?.buttons) {
        blockData.buttons.forEach((btnBlock: any) => {
          if (Array.isArray(btnBlock.buttons)) {
            buttonsArray = buttonsArray.concat(btnBlock.buttons);
          }
        });
      } else {
        buttonsArray = blockData.buttons;
      }
      if (buttonsArray.length > 0) {
        replyOptions.reply_markup = buildInlineKeyboard(buttonsArray);
      }
    }

    let sentMsg;
    if (blockData.media && typeof blockData.media.url === 'string' && blockData.media.url.trim() !== "") {
      const mediaUrl = getTestMediaUrl(blockData.media.url);
      console.log(`[DEBUG] blockData.media:`);
      console.dir(blockData.media, { depth: null });
      console.log(`[DEBUG] Sending photo with test URL: "${mediaUrl}" and caption: "${text}"`);
      sentMsg = await ctx.replyWithPhoto(mediaUrl, {
        caption: text,
        ...replyOptions,
      });
    } else {
      sentMsg = await ctx.reply(text, replyOptions);
    }
    if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
      ctx.session.previousMessages.push(sentMsg.message_id);
      console.log(`[DEBUG] Stored message ID: ${sentMsg.message_id}. Current previousMessages: ${ctx.session.previousMessages}`);
    }
  } catch (error: any) {
    console.error('Error processing MessageBlock:', error);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/initializeBots.ts
// Version: 1.4.7-refactored
// Рефакторинг: Обновлены импорты типов (BotContext, SessionData, UnifiedBotInterface) из единого файла TelegramBlocksTypes.ts,
// добавлено явное указание типа для начального состояния сессии с двумя типовыми аргументами,
// оставлены отдельные вызовы bot.use для регистрации различных middleware.
// Добавлена логика обновления описания бота на этапе инициализации (до вызова bot.start()).
// Теперь инициализируются только боты, у которых поле enabled имеет значение "enabled".
// Добавлено новое свойство protectContent в UnifiedBotConfig и передаётся из raw данных.

import type { Payload } from 'payload';
import { Bot as TelegramBot, session } from 'grammy';

import { bannedClientHook } from '@/plugins/TelegramAPI/utils/ClientUtils/bannedClient';
import { processClient } from '@/plugins/TelegramAPI/utils/ClientUtils/processClient';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { handleCatalogEvent } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';
import { goBackState } from '@/plugins/TelegramAPI/utils/SystemUtils/goBackState';
// Импорт типов из общего файла
import type { BotContext, SessionData, UnifiedBotInterface } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export type { BotContext };

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  protectContent?: boolean;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/**
 * Объединяет данные из объекта бота (из коллекции Bots)
 * в единый объект настроек (UnifiedBotConfig). Если rawBotData.interface присутствует,
 * его поля объединяются с набором дефолтных значений; если отсутствует – подставляются дефолтные значения.
 */
export function createUnifiedBotConfig(rawBotData: any): UnifiedBotConfig {
  const defaultInterface: UnifiedBotInterface = {
    blocks: [],
    defaultStartLayout: 'start',
    defaultFirstVisitLayout: 'start_first_visit',
    total_visit: 0,
  };
  return {
    id: rawBotData.id,
    name: rawBotData.name,
    token: rawBotData.token,
    description: rawBotData.description,
    enabled: rawBotData.enabled,
    protectContent: rawBotData.protectContent, // Передаем значение поля protectContent из raw данных
    initialization_status: rawBotData.initialization_status,
    last_initialized: rawBotData.last_initialized,
    interface: {
      blocks: Array.isArray(rawBotData.interface?.blocks) ? rawBotData.interface.blocks : defaultInterface.blocks,
      defaultStartLayout: rawBotData.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: rawBotData.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof rawBotData.interface?.total_visit === 'number'
        ? rawBotData.interface.total_visit
        : defaultInterface.total_visit,
    },
  };
}

export async function initializeBots(payload: Payload): Promise<void> {
  try {
    log('info', 'Поиск активных ботов...', payload);
    // Фильтрация: инициализируются только боты, у которых enabled === "enabled"
    const { docs: bots } = await payload.find({
      collection: 'bots',
      where: { enabled: { equals: 'enabled' } },
      limit: 999,
    });
    log('info', `Найдено ${bots.length} ботов для инициализации.`, payload);

    for (const botData of bots) {
      const unifiedBotData = createUnifiedBotConfig(botData);
      if (unifiedBotData.enabled !== 'enabled') {
        log('info', `Бот "${unifiedBotData.name}" не включён (enabled=${unifiedBotData.enabled}). Пропускаем инициализацию.`, payload);
        continue;
      }
      const botConfig = new BotConfig(unifiedBotData);

      console.log('BotConfig:', JSON.stringify(botConfig, null, 2));
      await initBot(payload, botConfig);
    }
  } catch (error: any) {
    log('error', `Ошибка при инициализации ботов: ${error.message}`, payload);
  }
}

async function initBot(payload: Payload, botConfig: BotConfig): Promise<void> {
  try {
    if (!botConfig.token) {
      log('error', `Пропущен бот "${botConfig.name}": отсутствует токен.`, payload);
      return;
    }
    const bot = new TelegramBot<BotContext>(botConfig.token);

    bot.use(
      session<SessionData, BotContext>({
        initial: (): SessionData => ({
          previousMessages: [] as number[],
          stateStack: [] as any[],
          previousState: undefined,
          currentState: undefined,
          isBanned: false,
          botConfig: botConfig, // Сохраняем настройки бота в сессии
        }),
      })
    );

    bot.use(bannedClientHook(payload));

    if (botConfig.description) {
      try {
        await bot.api.setMyDescription(botConfig.description);
        log('info', `Описание бота успешно обновлено.`, payload);
      } catch (error: any) {
        log('error', `Ошибка при обновлении описания бота: ${error.message}`, payload);
      }
    }

    bot.command('start', async (ctx) => {
      try {
        log('info', `Получена команда /start от пользователя ${ctx.from?.id}.`, payload);
        const telegramId = ctx.from?.id;
        if (!telegramId) {
          await ctx.reply('Ошибка: Telegram ID не найден.');
          return;
        }
        const client = await processClient(payload, telegramId, botConfig.id, {
          first_name: ctx.from?.first_name,
          last_name: ctx.from?.last_name,
          username: ctx.from?.username,
        });
        ctx.session.isBanned = client.isBanned;
        if (!client.isBanned) {
          const layoutAlias = client.total_visit === 1
            ? botConfig.interface.defaultFirstVisitLayout
            : botConfig.interface.defaultStartLayout;
          log('info', `Выбран layoutAlias: ${layoutAlias} (client.total_visit=${client.total_visit})`, payload);
          if (layoutAlias) {
            const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === layoutAlias);
            if (layoutBlock) {
              ctx.session.previousState = layoutBlock;
              await sendLayoutBlock(ctx, botConfig, payload, layoutAlias);
            } else {
              await ctx.reply(`Ошибка: Лейаут с alias "${layoutAlias}" не найден.`);
            }
          } else {
            await ctx.reply('Ошибка: Не удалось определить layout alias.');
          }
        } else {
          await ctx.reply('Ваш аккаунт заблокирован.');
        }
        ctx.session.botConfig = botConfig; // Обновляем настройки бота в сессии
      } catch (error: any) {
        log('error', `Ошибка обработки команды /start: ${error.message}`, payload);
      }
    });

    bot.on('callback_query:data', async (ctx) => {
      if (!ctx.callbackQuery || !ctx.callbackQuery.data) return;
      try {
        const data = ctx.callbackQuery.data;
        const parts = data.split('|');
        const cbType = parts[0]?.trim() ?? '';
        const callbackAlias = parts[1]?.trim() ?? '';

        if (cbType === 'layout' && callbackAlias === 'go_back_state') {
          await goBackState(ctx, payload, botConfig);
        } else if (cbType === 'catalogCategory' || cbType === 'catalogLoadMore') {
          await handleCatalogEvent(cbType, callbackAlias, '', ctx, payload);
          log('info', `Callback "${cbType}|${callbackAlias}" обработан через handleCatalogEvent.`, payload);
        } else {
          switch (cbType) {
            case 'layout': {
              const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === callbackAlias);
              if (layoutBlock) {
                ctx.session.previousState = layoutBlock;
                await sendLayoutBlock(ctx, botConfig, payload, callbackAlias);
              } else {
                await ctx.reply(`Ошибка: Лейаут с alias "${callbackAlias}" не найден.`);
              }
              break;
            }
            case 'message': {
              await processMessageBlock(ctx, { text: callbackAlias });
              log('info', `MessageBlock "${callbackAlias}" успешно обработан.`, payload);
              break;
            }
            case 'command': {
              if (callbackAlias === 'go_back_state') {
                await goBackState(ctx, payload, botConfig);
              } else {
                await ctx.reply(`Неизвестная команда: ${callbackAlias}`);
              }
              break;
            }
            default: {
              await ctx.reply(`Неизвестный тип callback: ${cbType}`);
            }
          }
        }
        await ctx.answerCallbackQuery();
      } catch (error: any) {
        log('error', `Ошибка обработки callback_query: ${error.message}`, payload);
      }
    });

    bot.start();
    log('info', `🤖 Бот "${botConfig.name}" успешно запущен.`, payload);

    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: {
        initialization_status: 'Initialized',
        last_initialized: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    log('error', `Ошибка при инициализации бота "${botConfig.name}": ${error.message}`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: { initialization_status: 'Error' },
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/BotConfig.ts
// Version: 1.4.7-refactored
//
// Рефакторинг: Обновлён конструктор для включения нового свойства protectContent.

import type { UnifiedBotConfig, UnifiedBotInterface } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

const defaultInterface: UnifiedBotInterface = {
  blocks: [],
  defaultStartLayout: 'start',
  defaultFirstVisitLayout: 'start_first_visit',
  total_visit: 0,
};

export class BotConfig {
  public id: number;
  public name: string;
  public token: string;
  public description?: string;
  public enabled: string;
  public initialization_status: string;
  public last_initialized?: string;
  public interface: UnifiedBotInterface;
  public protectContent: boolean;

  constructor(data: UnifiedBotConfig) {
    this.id = data.id;
    this.name = data.name;
    this.token = data.token;
    this.description = data.description;
    this.enabled = data.enabled;
    this.initialization_status = data.initialization_status;
    this.last_initialized = data.last_initialized;
    this.interface = {
      blocks: data.interface?.blocks ?? defaultInterface.blocks,
      defaultStartLayout: data.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: data.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof data.interface?.total_visit === 'number'
        ? data.interface.total_visit
        : defaultInterface.total_visit,
    };
    this.protectContent = (data as any).protectContent ?? false;
  }

  get telegramApiToken(): string {
    return this.token;
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/goBackState.ts
// Version: 1.0.4-goBack_stack
// Рефакторинг: Используем stateStack и currentState для корректного возврата к предыдущему состоянию.

import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { clearPreviousMessages } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

export async function goBackState(ctx: BotContext, payload: Payload, botConfig: any): Promise<void> {
  try {
    // Очищаем все предыдущие сообщения
    await clearPreviousMessages(ctx);

    // Извлекаем предыдущее состояние из стека, если оно есть
    let previousState = null;
    if (ctx.session.stateStack && ctx.session.stateStack.length > 0) {
      previousState = ctx.session.stateStack.pop();
    } else if (ctx.session.currentState) {
      // Если стек пуст, можно использовать текущее состояние как fallback
      previousState = ctx.session.currentState;
    }

    if (!previousState || !previousState.alias) {
      await ctx.reply('Предыдущее состояние не найдено.');
      return;
    }

    // Обновляем текущее состояние
    ctx.session.currentState = previousState;

    // Восстанавливаем layout по alias предыдущего состояния
    await sendLayoutBlock(ctx, botConfig, payload, previousState.alias);
    log('info', 'Команда go_back_state выполнена успешно. Пользователь возвращён к предыдущему состоянию.', payload);
  } catch (error: any) {
    log('error', `Ошибка выполнения команды go_back_state: ${error.message}`, payload);
    await ctx.reply('Ошибка при возврате в предыдущее состояние.');
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages.ts
// Version: 1.3.6-refactored
// Рефакторинг: Импорты типов SessionData и BotContext заменены на общий файл TelegramBlocksTypes.ts.

import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function clearPreviousMessages(ctx: BotContext): Promise<void> {
  if (!ctx.chat || !ctx.session || !Array.isArray(ctx.session.previousMessages)) {
    log('debug', 'Контекст чата или данные сессии недоступны.');
    return;
  }
  const chatId = ctx.chat.id;
  const messageIds = ctx.session.previousMessages;
  try {
    for (const msgId of messageIds) {
      try {
        await ctx.api.editMessageReplyMarkup(chatId, msgId, { reply_markup: undefined });
      } catch (error: any) {}
      try {
        await ctx.api.deleteMessage(chatId, msgId);
      } catch (error: any) {}
    }
  } catch (err: any) {
    // Обработка ошибки
  } finally {
    ctx.session.previousMessages = [];
  }
}

export function storeMessageId(ctx: BotContext, messageId: number): void {
  if (!messageId) return;
  if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
    ctx.session.previousMessages.push(messageId);
  }
}
// 📌 Путь: src/plugins/TelegramAPI/utils/SystemUtils/Logger.ts
// 📌 Версия: 1.1.0
//
// [CHANGELOG]
// - Восстановлен импорт `Payload` для устранения ошибки компиляции.
// - Актуализированы комментарии и добавлена проверка на корректность экземпляра `Payload`.
// - Улучшена обработка ошибок в блоке Payload CMS логирования.

import type { Payload } from 'payload';

/**
 * Функция логирования.
 * @param {string} level - Уровень логирования ('info', 'debug', 'error').
 * @param {string} message - Сообщение для логирования.
 * @param {Payload} [payload] - Экземпляр Payload CMS для записи лога.
 * @param {Record<string, any>} [context] - Дополнительные данные для логирования (например, объект контекста).
 */
export function log(
  level: 'info' | 'debug' | 'error',
  message: string,
  payload?: Payload,
  context?: Record<string, any>
): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

  // Вывод в консоль
  if (context && Object.keys(context).length > 0) {
    console.log(logMessage, context);
  } else {
    console.log(logMessage);
  }

  // Вывод через Payload CMS, если доступно
  if (payload?.logger && typeof payload.logger[level] === 'function') {
    try {
      payload.logger[level](message, context || {});
    } catch (err: any) {
      console.error(
        `[${timestamp}] [ERROR] Ошибка логирования через Payload CMS: ${err.message || 'Неизвестная ошибка'}`
      );
    }
  }
}
// Path: src/plugins/TelegramAPI/types/TelegramBlocksTypes.ts
// Version: 2.0.3
// Рефакторинг: Объединение всех объявлений полей и типов в один общий файл.
// Добавлены свойства currentState и botConfig в интерфейс SessionData для хранения текущего состояния и настроек бота.

import type { Context, SessionFlavor } from 'grammy';
import type { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

/** ===============================
 * 1. Типы блоков для Telegram
 * =============================== */

export enum BlockType {
  Layout = 'layout-blocks',
  Catalog = 'catalog-blocks',
  Message = 'message-blocks',
  Button = 'button-blocks',
  Command = 'command-blocks',
}

export interface TelegramLayoutBlock {
  blockType: BlockType.Layout;
  name: string;
  alias: string;
  blocks: TelegramSubBlock[];
  clearPreviousMessages?: boolean;
}

export interface TelegramCatalogBlock {
  blockType: BlockType.Catalog;
  name: string;
  alias: string;
  itemsPerPage?: number;
}

export interface TelegramMessageBlock {
  blockType: BlockType.Message;
  text: string;
}

export interface TelegramButtonBlock {
  blockType: BlockType.Button;
  text: string;
  callbackType: 'link' | 'message' | 'layout' | 'command';
}

export interface TelegramCommandBlock {
  blockType: BlockType.Command;
  command: string;
  responseText: string;
}

export type TelegramSubBlock =
  | TelegramLayoutBlock
  | TelegramCatalogBlock
  | TelegramMessageBlock
  | TelegramButtonBlock
  | TelegramCommandBlock;

/** ====================================
 * 2. Типы для клиентских данных
 * ==================================== */

export interface FromData {
  first_name?: string;
  last_name?: string;
  username?: string;
}

/** ====================================
 * 3. Типы для рендеринга элементов каталога
 * ==================================== */

export interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

/** ====================================
 * 4. Типы для настроек бота
 * ==================================== */

export interface UnifiedBotInterface {
  blocks: TelegramSubBlock[];
  defaultStartLayout: string;
  defaultFirstVisitLayout: string;
  total_visit: number;
}

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/** ====================================
 * 5. Типы для сессии и контекста бота
 * ==================================== */

export interface SessionData {
  previousMessages: number[];
  stateStack: any[];
  previousState?: any;
  currentState?: TelegramLayoutBlock;
  isBanned: boolean;
  // Хранит настройки бота, чтобы, например, использовать параметр protectContent
  botConfig?: BotConfig;
}

export type BotContext = Context & SessionFlavor<SessionData>;