Оптимизация типизации в TelegramAPI - плагине
В этом сообщении ниже, я пришлю код плагина для анализа и добавления в память диалога для дальнейшей доработки.
Эта версия считается СТАБИЛЬНОЙ и мы будем её дорабатывать без потери функционал.

На первом этапе доработок нам нужно исправить ошибки типизации, а точнее перенести определение полей и их типов в один общий файл, при это обновив соответствующией файлы плагина.
Важно сохранить функционал и не создавать ошибок. Изменения вностим только в те места кода которые относятся к данной задаче, не затрагивая другие части так как они работают правильно.

-------------------------

ИНСТРУКЦИИ. ЗАПОМНИ - ВАЖНО!
1. Всегда указывай пути до файлов
2. Подробные комментраии в коде
3. Помни всю историю диалога
4. Запомянай все ошибки и решения к ним.
5. В коментариях кода первая строка путь до файла от корня.
6. Каждый файл помечай коментами версия редактирования
7. иструкия по шагам.
8. Завай уточняющие вопросы, запомянай ответы на них
9. Отвечай всегда по русски
10. Не удаляй уже реализованный функционал, мы дорабатываем и рефакторим без потери функционала
11. Места редактирования кода помечаем комментариями
12. проставляем TODO там где это небоходимо.
13. Анализируй код файлов в связке, не допускай дублирования логики и функционала.
14. Придерживайся стандартов Payloadcms 3 и grammyjs

Запомни эти инструкции и чётко следуй им при выполнении заданий.
Зарание благодарю!

-------------------------

// Path: src/plugins/TelegramAPI/index.TelegramAPI.ts
// Version: 5.7.0
// Рефакторинг: Используется единая логика инициализации ботов из файла initializeBots.ts.
// Коллекции Bots и Clients регистрируются в плагине.
import type { Payload, Config, Plugin } from 'payload';
import Bots from '@/collections/TelegramAPI/Bots';
import Clients from '@/collections/TelegramAPI/Clients';
import { initializeBots } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const TelegramAPIPlugin: Plugin = (incomingConfig: Config): Config => {
  return {
    ...incomingConfig,
    collections: [
      ...(incomingConfig.collections || []),
      Bots,
      Clients,
    ],
    onInit: async (payload: Payload) => {
      log('info', 'TelegramAPIPlugin initialization started.', payload);
      await initializeBots(payload);
      log('info', 'TelegramAPIPlugin initialized successfully.', payload);
    },
  };
};

export default TelegramAPIPlugin;
// Path: src/plugins/TelegramAPI/utils/ClientUtils/processClient.ts
// Version: 1.3.8-stable
//
// [CHANGELOG]
// - При создании нового клиента поле status не передаётся, чтобы установить значение по умолчанию через вебхук/коллекцию.
// - Добавлено логирование значения client.status после создания/обновления клиента.
// - Нормализовано поле bots для устранения ошибок типов.
// - Поле status не изменяется ботом – изменение статуса происходит только через админ-панель.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

interface FromData {
  first_name?: string;
  last_name?: string;
  username?: string;
}

export async function processClient(
  payload: Payload,
  telegramId: number,
  botId: number,
  fromData: FromData
): Promise<any> {
  try {
    log('info', `[processClient] Searching for client with telegram_id=${telegramId} and bot=${botId}`, payload);

    const { docs } = await payload.find({
      collection: 'clients',
      where: { telegram_id: { equals: telegramId } },
      limit: 1,
    });

    let client: any;

    if (!docs || docs.length === 0) {
      log('info', "[processClient] No existing client found, creating a new one...", payload);
      client = await payload.create({
        collection: 'clients',
        data: {
          telegram_id: telegramId,
          bots: [botId],
          first_name: fromData.first_name ?? "",
          last_name: fromData.last_name ?? "",
          user_name: fromData.username || 'anonymous_user',
          total_visit: 1,
          last_visit: new Date().toISOString(),
          enabled: "enabled"
          // Поле status не передаётся, чтобы значение установилось через defaultValue или beforeChange-хук в коллекции.
        },
      });
    } else {
      const existingClient = docs[0]!;
      log('info', `[processClient] Client found: ID=${existingClient.id}`, payload);
      let botsArray: any[] = Array.isArray(existingClient.bots)
        ? existingClient.bots
        : existingClient.bots ? [existingClient.bots] : [];
      if (!botsArray.some(b =>
        b != null && typeof b === 'object'
          ? b.id !== undefined && b.id.toString() === botId.toString()
          : b != null && b.toString() === botId.toString()
      )) {
        botsArray.push(botId);
        log('info', `[processClient] Bot ${botId} added to client ${existingClient.id}`, payload);
      }
      client = await payload.update({
        collection: 'clients',
        id: existingClient.id,
        data: {
          bots: botsArray,
          first_name: fromData.first_name ?? existingClient.first_name ?? "",
          last_name: fromData.last_name ?? existingClient.last_name ?? "",
          user_name: fromData.username || existingClient.user_name || 'anonymous_user',
          last_visit: new Date().toISOString(),
          total_visit: (existingClient.total_visit ?? 0) + 1,
        },
      });
    }

    log('debug', `[processClient] Client status: ${client.status}`, payload);
    const statusAlias = await checkClientStatus(payload, client.status);
    log('debug', `[processClient] Retrieved status alias: ${statusAlias}`, payload);
    const isBanned = statusAlias === 'banned';

    if (isBanned) {
      log('info', `[processClient] Client ID=${client.id} is banned. Updating status...`, payload);
      client = await payload.update({
        collection: 'clients',
        id: client.id,
        data: {
          enabled: "disabled",
        },
      });
      client.isBanned = true;
    } else {
      client.isBanned = false;
    }

    return client;
  } catch (error: any) {
    log('error', `[processClient] Error processing client: ${error.message}`, payload);
    return { total_visit: 1 };
  }
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/checkClientStatus.ts
// Version: 1.1.5-stable
//
// [CHANGELOG]
// - Добавлена поддержка числовых значений в поле status.
// - Если status равен undefined или null, возвращается "new" как значение по умолчанию.
// - Если status – объект с полем alias, возвращается alias; если статус – число или строка, выполняется запрос к коллекции "statuses".
// - Используется единый логгер log для отладки.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function checkClientStatus(
  payload: Payload,
  status: any
): Promise<string | null> {
  try {
    if (status === undefined || status === null) {
      log('debug', 'checkClientStatus: status is undefined or null, defaulting to "new"');
      return "new";
    }
    if (typeof status === 'object') {
      if ('alias' in status && typeof status.alias === 'string') {
        return status.alias;
      }
      if ('id' in status) {
        const statusResult = await payload.find({
          collection: 'statuses',
          where: { id: { equals: status.id } },
          limit: 1,
        });
        const statusDoc = statusResult.docs[0];
        return statusDoc?.alias || "new";
      }
    }
    if (typeof status === 'number' || typeof status === 'string') {
      const statusResult = await payload.find({
        collection: 'statuses',
        where: { id: { equals: status } },
        limit: 1,
      });
      const statusDoc = statusResult.docs[0];
      return statusDoc?.alias || "new";
    }
  } catch (error: any) {
    log('error', `❌ Ошибка в checkClientStatus: ${error.message}`, payload);
  }
  return "new";
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/bannedClient.ts
// Version: 1.2.3-stable
//
// [CHANGELOG]
// - Объединена логика проверки бана в один middleware.
// - Сначала проверяется сессионный флаг isBanned; если он установлен, дальнейшая обработка прекращается.
// - Если флаг не установлен, выполняется проверка статуса клиента через checkClientStatus.
// - Если alias равен "banned", отправляется сообщение и флаг isBanned сохраняется в сессии.
// - Используется единый логгер log для отладки.
import type { Context } from 'grammy';
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

export function bannedClientHook(payload: Payload) {
  return async (ctx: Context & { session: any }, next: () => Promise<void>): Promise<void> => {
    try {
      if (ctx.session.isBanned) {
        await ctx.reply("💀 Your account is locked! 💀 \n\n🚷 You've been banned.");
        log('info', 'bannedClientHook: Session indicates client is banned, skipping processing.', payload);
        return;
      }
      if (ctx.from) {
        const telegramId = ctx.from.id;
        const { docs } = await payload.find({
          collection: 'clients',
          where: { telegram_id: { equals: telegramId } },
          limit: 1,
        });
        const client = docs.length > 0 ? docs[0] : null;
        if (client && client.status) {
          const statusAlias = await checkClientStatus(payload, client.status);
          if (statusAlias === 'banned') {
            await ctx.reply("💀 Your account is locked! 💀 \n\n🚷 You've been banned.");
            log('info', `bannedClientHook: Client ID=${client.id} is banned according to DB check.`, payload);
            ctx.session.isBanned = true;
            return;
          }
        }
      }
      await next();
    } catch (error: any) {
      log('error', `bannedClientHook: Error checking ban status: ${error.message}`, payload);
      await next();
    }
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock.ts
// Version: 1.3.6 (с исправлениями TS18048)
// [CHANGELOG]
// - Если aliasOverride не задан, используется botConfig.interface.defaultStartLayout.
// - Добавлена проверка наличия botConfig.interface и её поля blocks.
// - После проверки используется оператор non‑null assertion для botConfig.interface.blocks.
// - Функционал обработки блоков остаётся без изменений.

import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index';
import { handleButtonBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

interface LayoutBlock {
  clearPreviousMessages: boolean;
  name: string;
  blocks: Array<{
    blockType: string;
    description?: string;
    [key: string]: any;
  }>;
}

const blockHandlers: Record<string, (ctx: BotContext, block: any, payload: Payload) => Promise<void>> = {
  messageblock: processMessageBlock,
  'message-blocks': processMessageBlock,
  buttonblock: async (ctx, block, payload) => {
    const description = block.description || 'Выберите действие:';
    await handleButtonBlock(ctx, block, description);
  },
  'button-blocks': async (ctx, block, payload) => {
    const description = block.description || 'Выберите действие:';
    await handleButtonBlock(ctx, block, description);
  },
  catalogblock: renderCatalogBlock,
  'catalog-blocks': renderCatalogBlock,
};

export async function sendLayoutBlock(
  ctx: BotContext,
  botConfig: any, // Ожидается объект типа BotConfig
  payload: Payload,
  aliasOverride?: string
): Promise<void> {
  // Если aliasOverride не задан, используем значение из botConfig.interface.defaultStartLayout
  const layoutAlias = aliasOverride ?? botConfig.interface?.defaultStartLayout;

  if (!layoutAlias) {
    await ctx.reply('Ошибка: Не удалось определить layout alias.');
    return;
  }

  try {
    log('debug', `Используемый layoutAlias: ${layoutAlias}`);
    log('debug', `BotConfig.interface: ${JSON.stringify(botConfig.interface)}`);

    // Если интерфейс отсутствует или блоков нет – выводим сообщение и завершаем
    if (!botConfig.interface || !botConfig.interface.blocks || botConfig.interface.blocks.length === 0) {
      await ctx.reply(`Layout "${layoutAlias}" не содержит блоков. Добавьте блоки.`);
      return;
    }

    // Используем non‑null assertion, так как выше проверено, что blocks определён и непустой
    const layoutBlock: LayoutBlock | undefined = botConfig.interface!.blocks.find(
      (block: any) => block.alias === layoutAlias
    );

    if (!layoutBlock) {
      const msg = await ctx.reply(`Layout "${layoutAlias}" не найден. Добавьте блоки.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    if (layoutBlock.clearPreviousMessages && ctx.chat) {
      log('debug', `Перед отправкой LayoutBlock "${layoutBlock.name}" очищаем предыдущие сообщения.`);
      await clearPreviousMessages(ctx);
    }

    if (!Array.isArray(layoutBlock.blocks) || layoutBlock.blocks.length === 0) {
      const msg = await ctx.reply(`Layout "${layoutBlock.name}" пуст. Добавьте блоки.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    for (const block of layoutBlock.blocks) {
      try {
        const blockType = block.blockType?.toLowerCase();
        const handler = blockHandlers[blockType];
        if (handler) {
          log('debug', `Обрабатываем блок типа "${blockType}"`);
          await handler(ctx, block, payload);
        } else {
          log('error', `Неизвестный тип блока: ${blockType}`, payload);
          const msg = await ctx.reply(`Неизвестный тип блока: ${block.blockType}`);
          storeMessageId(ctx, msg.message_id);
        }
      } catch (blockError) {
        log('error', `Ошибка обработки блока: ${(blockError as Error).message}`, payload);
        const msg = await ctx.reply(`Произошла ошибка при обработке блока: ${layoutBlock.name}`);
        storeMessageId(ctx, msg.message_id);
      }
    }
  } catch (error: any) {
    log('error', `Общая ошибка при обработке лейаута "${layoutAlias}": ${(error as Error).message}`, payload);
    const errorMsg = await ctx.reply(`Произошла ошибка при обработке лейаута: "${layoutAlias}"`);
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// 📌 Путь: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/index.TelegramAPI.ts
// 📌 Версия: 1.2.0
//
// [CHANGELOG]
// - Убрана попытка загружать подкатегории и товары на главной странице `CatalogBlock`.
// - Добавлено описание вывода только первого уровня категорий.
// - Добавлена обработка отсутствия категорий.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

/**
 * Отображение `CatalogBlock`.
 * @param {BotContext} ctx - Контекст Telegram бота.
 * @param {any} block - Блок каталога.
 * @param {Payload} payload - Экземпляр Payload CMS.
 */
export async function renderCatalogBlock(ctx: BotContext, block: any, payload: Payload): Promise<void> {
  try {
    if (!block || !ctx.chat) {
      throw new Error('Некорректный блок или контекст чата.');
    }

    const inlineKeyboard = new InlineKeyboard();

    // Загрузка категорий первого уровня
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } }, // Только категории верхнего уровня
      limit: 999,
    });

    const categories = categoriesResult.docs;

    // Если категории отсутствуют
    if (categories.length === 0) {
      await ctx.reply('Категории отсутствуют.');
      log('info', 'Категории для отображения отсутствуют.', payload);
      return;
    }

    // Генерация кнопок для категорий
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row(); // Новый ряд каждые 2 кнопки
    });

    // Отправка сообщения с обложкой и описанием
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || 'Пожалуйста, выберите категорию:';

    await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });

    log('info', `Каталог успешно отображён для пользователя ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `Ошибка отображения CatalogBlock: ${error.message}`, payload);
    await ctx.reply('Произошла ошибка при загрузке каталога.');
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItems.ts
// Version: 1.4.10.1
//
// [CHANGELOG]
// - Функция теперь принимает внешний параметр clearMessages, который полностью определяет, нужно ли очищать предыдущие сообщения.
// - Очистка сообщений больше не основана на проверке номера страницы или активной категории внутри функции.
// - Логика вывода информации о категории, подкатегорий и товаров с пагинацией остаётся прежней.
import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';

interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

export async function renderCategoryItems(
  ctx: BotContext,
  categoryId: string,
  options: RenderOptions,
  payload: Payload,
  clearMessages: boolean = true
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }
    // Полностью полагаемся на внешний параметр clearMessages
    if (clearMessages) {
      await clearPreviousMessages(ctx);
    }
    const category = await payload.findByID({
      collection: 'product-categories',
      id: categoryId,
    });
    if (!category) {
      log('error', `Категория с ID "${categoryId}" не найдена.`, payload);
      const msg = await ctx.reply('Ошибка: категория не найдена.');
      storeMessageId(ctx, msg.message_id);
      return;
    }
    const categoryMedia = Array.isArray(category.media) && category.media.length > 0
      ? category.media
      : [{ url: 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png' }];
    const categoryCaption = `<b>${category.name}</b>\n${category.description || ''}`;
    const categoryMsg = await ctx.replyWithPhoto(categoryMedia[0].url, {
      caption: categoryCaption,
      parse_mode: 'HTML',
    });
    storeMessageId(ctx, categoryMsg.message_id);

    let subcategories: any[] = [];
    let products: any[] = [];

    if (options.displayMode === 'subcategories' || options.displayMode === 'all') {
      const subResult = await payload.find({
        collection: 'product-categories',
        where: { parent_id: { equals: categoryId } },
        limit: 999,
      });
      subcategories = subResult.docs;
    }

    let totalPages = 0;
    if (options.displayMode === 'products' || options.displayMode === 'all') {
      const productPagination = await paginateCategoryItems(
        payload,
        'products',
        { category_ids: { in: [parseInt(categoryId, 10)] } },
        options.page,
        options.itemsPerPage
      );
      products = productPagination.docs;
      totalPages = productPagination.totalPages;
    }

    if (subcategories.length === 0 && products.length === 0) {
      const emptyMessage = await ctx.reply('Категория пуста. Нет данных для отображения.');
      storeMessageId(ctx, emptyMessage.message_id);
      return;
    }

    if (subcategories.length > 0 && (options.displayMode === 'subcategories' || options.displayMode === 'all')) {
      const subKeyboard = new InlineKeyboard();
      subcategories.forEach((subcat: any, index: number) => {
        subKeyboard.text(subcat.name, `catalogCategory|${subcat.id}`);
        if ((index + 1) % 2 === 0) subKeyboard.row();
      });
      const subMsg = await ctx.reply('Подкатегории:', { reply_markup: subKeyboard });
      storeMessageId(ctx, subMsg.message_id);
    }

    if (products.length > 0 && (options.displayMode === 'products' || options.displayMode === 'all')) {
      for (const product of products) {
        await renderProductCard(ctx, product.id, payload);
      }
      // Кнопка "Загрузить ещё" отображается только если текущая страница меньше общего числа страниц
      if (options.page < totalPages) {
        const navKeyboard = new InlineKeyboard().text(
          "Загрузить ещё",
          `catalogLoadMore|${categoryId}|${options.page + 1}|${options.itemsPerPage}`
        );
        const navMsg = await ctx.reply(`Страница ${options.page}`, { reply_markup: navKeyboard });
        storeMessageId(ctx, navMsg.message_id);
      }
    }
    log('info', `Элементы категории успешно отправлены для ID: ${categoryId}.`, payload);
  } catch (error: any) {
    log('error', `Ошибка при рендеринге элементов категории: ${error.message}`, payload);
    const errorMsg = await ctx.reply('Произошла ошибка при загрузке данных категории.');
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/paginateCategoryItems.ts
// Version: 1.1.2
//
// [CHANGELOG]
// - Функция теперь возвращает объект с полями docs и totalPages для корректной проверки наличия следующих страниц.
import type { Payload, CollectionSlug } from 'payload';

export async function paginateCategoryItems(
  payload: Payload,
  collection: CollectionSlug,
  where: Record<string, any>,
  page: number,
  itemsPerPage: number,
): Promise<{ docs: any[]; totalPages: number }> {
  try {
    const result = await payload.find({
      collection,
      where,
      limit: itemsPerPage,
      page,
      sort: 'name',
    });
    return {
      docs: result.docs || [],
      totalPages: result.totalPages || Math.ceil((result.totalDocs || 0) / itemsPerPage),
    };
  } catch (error: any) {
    console.error(`Ошибка при пагинации коллекции "${collection}":`, error);
    throw new Error(`Ошибка при загрузке данных из коллекции "${collection}".`);
  }
}

export function generatePaginationData(
  currentPage: number,
  totalItems: number,
  itemsPerPage: number,
): {
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
} {
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  return {
    currentPage,
    totalPages,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItemsLoadMore.ts
// Version: 1.0.39
//
// [CHANGELOG]
// - Использование обновлённой функции paginateCategoryItems, которая возвращает totalPages.
// - Если текущая страница равна totalPages, кнопка "Загрузить ещё" не выводится.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';

const DEMO_PRODUCT_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderCategoryItemsLoadMore(
  ctx: any,
  categoryId: string,
  payload: Payload,
  page: number,
  itemsPerPage: number = 3
): Promise<void> {
  try {
    log('info', `Подгружаем товары для категории ${categoryId}, страница ${page}, itemsPerPage=${itemsPerPage}`, payload);
    const productPagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = productPagination.docs;
    const totalPages = productPagination.totalPages;
    if (!products || products.length === 0) {
      const noMoreMsg = await ctx.reply("Нет больше товаров.", { parse_mode: 'HTML' });
      storeMessageId(ctx, noMoreMsg.message_id);
      log('info', `Товары закончились для категории ${categoryId}`, payload);
      return;
    }
    for (const product of products) {
      const productKeyboard = new InlineKeyboard()
        .text("Подробнее", `catalogProductDetails|${product.id}`)
        .text("Купить", `catalogBuyNow|${product.id}`);
      const productMsg = await ctx.replyWithPhoto(DEMO_PRODUCT_IMAGE_URL, {
        caption: `<b>${product.name}</b>\n<b>Цена:</b> ${product.price ? `$${product.price}` : 'N/A'}\n<b>Статус:</b> ${product.status ?? 'Неизвестно'}`,
        parse_mode: 'HTML',
        reply_markup: productKeyboard,
      });
      storeMessageId(ctx, productMsg.message_id);
    }
    if (page < totalPages) {
      const navKeyboard = new InlineKeyboard()
        .text("Загрузить ещё", `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`);
      const navMsg = await ctx.reply(`Страница ${page}`, {
        parse_mode: 'HTML',
        reply_markup: navKeyboard,
      });
      storeMessageId(ctx, navMsg.message_id);
    }
  } catch (error: any) {
    log('error', `Ошибка в renderCategoryItemsLoadMore: ${error.message}`, payload);
    await ctx.reply("Произошла ошибка при подгрузке товаров.");
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers.ts
// Version: 1.2.6
//
// [CHANGELOG]
// - Изменена логика разбора callback‑данных.
// - Для события "catalogCategory" callback‑данные теперь должны быть в формате: "catalogCategory|<categoryId>|<itemsPerPage>".
// - Для события "catalogLoadMore" callback‑данные должны быть: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>".
// - Обработчик извлекает параметры из callback‑данных и передаёт их в соответствующие функции.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { renderCategoryItems } from './renderCategoryItems';
import { renderCategoryItemsLoadMore } from './renderCategoryItemsLoadMore';

interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

export async function handleCatalogEvent(
  cbType: string,
  _unused: string, // больше не используется, параметры будут извлечены из callback данных
  _unused2: string | undefined,
  ctx: BotContext,
  payload: Payload,
): Promise<void> {
  try {
    if (!ctx.callbackQuery || !ctx.callbackQuery.data) {
      throw new Error('Данные callback отсутствуют.');
    }
    const parts = (ctx.callbackQuery.data as string).split('|');
    const eventType = parts[0]?.trim() ?? '';
    if (eventType === 'catalogCategory') {
      // Для catalogCategory ожидаем формат: "catalogCategory|<categoryId>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawItemsPerPage = parts[2]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `Некорректный идентификатор категории: "${rawCategoryId}".`, payload);
        await ctx.reply('Ошибка: некорректный идентификатор категории.');
        return;
      }
      const options: RenderOptions = {
        page: 1,
        itemsPerPage,
        displayMode: "all", // здесь можно настроить динамически, если потребуется
      };
      // При переходе в новую категорию очищаем предыдущие сообщения
      await renderCategoryItems(ctx, categoryId.toString(), options, payload, true);
    } else if (eventType === 'catalogLoadMore') {
      // Для catalogLoadMore ожидаем формат: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawPageValue = parts[2]?.trim() ?? "1";
      const rawItemsPerPage = parts[3]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const nextPage = parseInt(rawPageValue, 10);
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `Некорректный идентификатор категории: "${rawCategoryId}".`, payload);
        await ctx.reply('Ошибка: некорректный идентификатор категории.');
        return;
      }
      const options: RenderOptions = {
        page: nextPage,
        itemsPerPage,
        displayMode: "all",
      };
      // При постраничной загрузке не очищаем сообщения
      await renderCategoryItemsLoadMore(ctx, categoryId.toString(), payload, nextPage, itemsPerPage);
    } else {
      await ctx.reply('Неизвестный тип события каталога.');
      log('error', `Неизвестный тип события каталога: ${eventType}`, payload);
    }
  } catch (error: any) {
    log('error', `Ошибка обработки события каталога: ${error.message}`, payload);
    await ctx.reply('Произошла ошибка при обработке события.');
  }
}
// Path: src/blocks/TelegramAPI/CatalogBlock/renderCatalogBlock.ts
// Version: 1.4.2
//
// [CHANGELOG]
// - Изменён формат callback‑данных для кнопок категорий: теперь передаётся значение itemsPerPage из настроек блока.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderCatalogBlock(
  ctx: BotContext,
  block: any,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }

    // Запрашиваем все категории верхнего уровня
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } },
      limit: 999,
    });
    const categories = categoriesResult.docs;
    if (categories.length === 0) {
      const emptyMsg = await ctx.reply('Категории отсутствуют.');
      storeMessageId(ctx, emptyMsg.message_id);
      log('info', 'Категории для отображения отсутствуют.', payload);
      return;
    }
    const inlineKeyboard = new InlineKeyboard();
    // Определяем значение itemsPerPage из настроек блока (если отсутствует – по умолчанию 3)
    const itemsPerPage = block.itemsPerPage ?? 3;
    // Формируем callback данные в формате: "catalogCategory|<categoryId>|<itemsPerPage>"
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}|${itemsPerPage}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row();
    });
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || 'Пожалуйста, выберите категорию:';
    const catalogMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });
    storeMessageId(ctx, catalogMsg.message_id);
    log('info', `Главная страница CatalogBlock успешно отображена для пользователя ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `Ошибка отображения CatalogBlock: ${error.message}`, payload);
    const errorMsg = await ctx.reply('Произошла ошибка при загрузке каталога.');
    if (errorMsg?.message_id) {
      storeMessageId(ctx, errorMsg.message_id);
    }
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductCard.ts
// Version: 1.0.12
//
// [CHANGELOG]
// - Удалён вызов clearPreviousMessages(ctx), чтобы не удалять уже выведенные карточки товара при постраничной подгрузке.
// - Остальная логика обработки продукта сохранена.
import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import {
  storeMessageId,
  BotContext,
} from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductCard(
  ctx: BotContext,
  productId: string,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', 'Контекст чата отсутствует.', payload);
      return;
    }
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const msg = await ctx.reply("Продукт не найден.", { parse_mode: 'HTML' });
      storeMessageId(ctx, msg.message_id);
      log('error', `Продукт с ID ${productId} не найден.`, payload);
      return;
    }
    const { name, price, description } = product as any;
    let messageText = `<b>${name}</b>\n<b>Цена:</b> $${price}\n`;
    messageText += `<b>Описание:</b> ${description || 'Нет описания'}\n`;
    const keyboard = new InlineKeyboard()
      .text("Назад", `catalogBack|${productId}`)
      .text("Заказать", `order|${productId}`);
    const cardMsg = await ctx.replyWithPhoto(DEMO_IMAGE_URL, {
      caption: messageText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
    storeMessageId(ctx, cardMsg.message_id);
    log('info', `Карточка продукта с ID ${productId} успешно отправлена.`, payload);
  } catch (error: any) {
    log('error', `Ошибка при отображении карточки продукта: ${error.message}`, payload);
    await ctx.reply(
      "Произошла ошибка при загрузке информации о продукте.",
      { parse_mode: 'HTML' }
    );
  }
}
// 📌 Путь: src/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock.ts
// 📌 Версия: 1.1.2
//
// [CHANGELOG]
// - Добавлено сохранение ID отправленных сообщений (с кнопками) в `previousMessages`.
// - Улучшено логирование для диагностики отправки кнопок и сообщений.
// - Обеспечено правильное управление сообщениями для последующего удаления.

import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

/**
 * Обработка кнопочного блока.
 * @param {BotContext} ctx - Контекст Telegram бота.
 * @param {any} buttonBlock - Объект кнопочного блока.
 * @param {string} [defaultDescription] - Описание блока кнопок, если описание не задано в buttonBlock.
 */
export async function handleButtonBlock(
  ctx: BotContext,
  buttonBlock: any,
  defaultDescription = 'Выберите действие:'
): Promise<void> {
  if (!ctx.chat) {
    log('error', 'Контекст чата отсутствует.', undefined);
    return;
  }

  // Проверка на наличие кнопок
  if (!Array.isArray(buttonBlock.buttons) || buttonBlock.buttons.length === 0) {
    log('error', 'Кнопочный блок не содержит кнопок.', undefined);
    const emptyMsg = await ctx.reply('Кнопочный блок пуст. Пожалуйста, настройте кнопки.');
    storeMessageId(ctx, emptyMsg.message_id); // Сохраняем сообщение, чтобы его можно было удалить
    return;
  }

  // Используем описание из buttonBlock или fallback на defaultDescription
  const description = buttonBlock.description || defaultDescription;

  const inlineKeyboard = new InlineKeyboard();

  // Генерация кнопок
  buttonBlock.buttons.forEach((btn: any) => {
    try {
      const callbackData = btn.callback_data || '';
      const buttonText = btn.text;

      switch (btn.callbackType) {
        case 'layout':
        case 'message':
        case 'command':
          inlineKeyboard.text(buttonText, `${btn.callbackType}|${callbackData}`);
          break;
        case 'link':
          inlineKeyboard.url(buttonText, btn.url || '');
          break;
        default:
          inlineKeyboard.text(buttonText, callbackData);
      }

      if (btn.newRow) {
        inlineKeyboard.row();
      }
    } catch (error: any) {
      log('error', `Ошибка при генерации кнопки: ${error.message}`, undefined);
    }
  });

  // Отправка кнопок
  try {
    const buttonMsg = await ctx.reply(description, { reply_markup: inlineKeyboard });
    storeMessageId(ctx, buttonMsg.message_id); // Сохраняем ID отправленного сообщения
    log('info', `Кнопки успешно отправлены. Сообщение ID: ${buttonMsg.message_id}`, undefined);
  } catch (error: any) {
    log('error', `Ошибка отправки кнопок: ${error.message}`, undefined);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index.TelegramAPI.ts
// Version: 1.0.9
//
// This utility processes a MessageBlock by sending its content using HTML formatting via grammY.
// For testing purposes, if a media file is attached, instead of using the media URL from the payload,
// a fixed URL is used:
//   https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg
// This is only for testing and should be removed or disabled in production.
// It uses standard Payload CMS v3 type definitions and grammY's Context type with session support.

import type { Context, SessionFlavor } from 'grammy';

interface SessionData {
  previousMessages: number[];
}

type BotContext = Context & SessionFlavor<SessionData>;

/**
 * For testing purposes, returns a fixed media URL.
 * In production, use getAbsoluteMediaUrl to compute the absolute URL.
 *
 * @param url - The media file URL (unused in testing).
 * @returns The fixed test media URL.
 */
function getTestMediaUrl(url: string): string {
  // Логирование для тестового URL
  console.log(`[DEBUG] Overriding media URL for testing. Original URL: "${url}"`);
  return "https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg";
}

export async function processMessageBlock(ctx: BotContext, blockData: any): Promise<void> {
  if (!ctx.chat) return;

  // Retrieve the text from the block. The text should already contain valid HTML formatting.
  const text: string = blockData.text || '';

  try {
    let sentMsg;
    // Если поле media задано и не пустое, для теста используем фиксированный URL.
    if (blockData.media && typeof blockData.media.url === 'string' && blockData.media.url.trim() !== "") {
      const mediaUrl = getTestMediaUrl(blockData.media.url);
      console.log(`[DEBUG] blockData.media:`);
      console.dir(blockData.media, { depth: null });
      console.log(`[DEBUG] Sending photo with test URL: "${mediaUrl}" and caption: "${text}"`);
      sentMsg = await ctx.replyWithPhoto(mediaUrl, {
        caption: text,
        parse_mode: 'HTML'
      });
    } else {
      sentMsg = await ctx.reply(text, { parse_mode: 'HTML' });
    }
    if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
      ctx.session.previousMessages.push(sentMsg.message_id);
      console.log(`[DEBUG] Stored message ID: ${sentMsg.message_id}. Current previousMessages: ${ctx.session.previousMessages}`);
    }
  } catch (error: any) {
    console.error('Error processing MessageBlock:', error);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/initializeBots.ts
// Version: 1.4.2-stable+goBack_final_fix
//
// [CHANGELOG]
// - Использование BotConfig для настройки ботов.
// - Функция createUnifiedBotConfig возвращает rawBotData.interface объединённое с дефолтными значениями.
// - Обработка команды /start: после processClient выбирается layout alias на основе total_visit клиента (если total_visit === 1 – используется defaultFirstVisitLayout, иначе defaultStartLayout).
// - Middleware bannedClientHook подключён для проверки статуса клиента.
// - В callback‑обработчике добавлены ветки для типов "catalogCategory" и "catalogLoadMore" для корректного открытия категорий,
//   а также – если callback с типом "layout" имеет alias "go_back_state", он перенаправляется в goBackState.
// - Механизм go_back_state реализован через вызов функции goBackState.
// - Тип BotContext экспортируется из модуля clearPreviousMessages.
import type { Payload } from 'payload';
import type { Config, Plugin } from 'payload';
import { Bot as TelegramBot, session } from 'grammy';

import { bannedClientHook } from '@/plugins/TelegramAPI/utils/ClientUtils/bannedClient';
import { processClient } from '@/plugins/TelegramAPI/utils/ClientUtils/processClient';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/index';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { handleCatalogEvent } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';
import { goBackState } from '@/plugins/TelegramAPI/utils/SystemUtils/goBackState';
// Импорт типов сессии и контекста для унификации
import type { BotContext, SessionData } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

export type { BotContext };

export interface UnifiedBotInterface {
  blocks: any[];
  defaultStartLayout: string;
  defaultFirstVisitLayout: string;
  total_visit: number;
}

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/**
 * Объединяет данные из объекта бота (из коллекции Bots)
 * в единый объект настроек (UnifiedBotConfig). Если rawBotData.interface присутствует,
 * его поля объединяются с набором дефолтных значений; если отсутствует – подставляются дефолтные значения.
 */
export function createUnifiedBotConfig(rawBotData: any): UnifiedBotConfig {
  const defaultInterface: UnifiedBotInterface = {
    blocks: [],
    defaultStartLayout: 'start',
    defaultFirstVisitLayout: 'start_first_visit',
    total_visit: 0,
  };
  return {
    id: rawBotData.id,
    name: rawBotData.name,
    token: rawBotData.token,
    description: rawBotData.description,
    enabled: rawBotData.enabled,
    initialization_status: rawBotData.initialization_status,
    last_initialized: rawBotData.last_initialized,
    interface: {
      blocks: Array.isArray(rawBotData.interface?.blocks) ? rawBotData.interface.blocks : defaultInterface.blocks,
      defaultStartLayout: rawBotData.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: rawBotData.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof rawBotData.interface?.total_visit === 'number'
        ? rawBotData.interface.total_visit
        : defaultInterface.total_visit,
    },
  };
}

export async function initializeBots(payload: Payload): Promise<void> {
  try {
    log('info', 'Поиск активных ботов...', payload);
    const { docs: bots } = await payload.find({
      collection: 'bots',
      where: { enabled: { equals: 'enabled' } },
      limit: 999,
    });
    log('info', `Найдено ${bots.length} ботов для инициализации.`, payload);

    for (const botData of bots) {
      const unifiedBotData = createUnifiedBotConfig(botData);
      const botConfig = new BotConfig(unifiedBotData);

      console.log('BotConfig:', JSON.stringify(botConfig, null, 2));
      await initBot(payload, botConfig);
    }
  } catch (error: any) {
    log('error', `Ошибка при инициализации ботов: ${error.message}`, payload);
  }
}

async function initBot(payload: Payload, botConfig: BotConfig): Promise<void> {
  try {
    if (!botConfig.token) {
      log('error', `Пропущен бот "${botConfig.name}": отсутствует токен.`, payload);
      return;
    }
    const bot = new TelegramBot<BotContext>(botConfig.token);

    bot.use(
      session<SessionData, BotContext>({
        initial: () => ({ previousMessages: [], stateStack: [], previousState: undefined, isBanned: false }),
      })
    );

    bot.use(bannedClientHook(payload));

    // Обработка команды /start
    bot.command('start', async (ctx) => {
      try {
        log('info', `Получена команда /start от пользователя ${ctx.from?.id}.`, payload);
        const telegramId = ctx.from?.id;
        if (!telegramId) {
          await ctx.reply('Ошибка: Telegram ID не найден.');
          return;
        }
        const client = await processClient(payload, telegramId, botConfig.id, {
          first_name: ctx.from?.first_name,
          last_name: ctx.from?.last_name,
          username: ctx.from?.username,
        });
        ctx.session.isBanned = client.isBanned;
        if (!client.isBanned) {
          const layoutAlias = client.total_visit === 1
            ? botConfig.interface.defaultFirstVisitLayout
            : botConfig.interface.defaultStartLayout;
          log('info', `Выбран layoutAlias: ${layoutAlias} (client.total_visit=${client.total_visit})`, payload);
          if (layoutAlias) {
            const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === layoutAlias);
            if (layoutBlock) {
              // Сохраняем текущее состояние для возможности возврата
              ctx.session.previousState = layoutBlock;
              await sendLayoutBlock(ctx, botConfig, payload, layoutAlias);
            } else {
              await ctx.reply(`Ошибка: Лейаут с alias "${layoutAlias}" не найден.`);
            }
          } else {
            await ctx.reply('Ошибка: Не удалось определить layout alias.');
          }
        } else {
          await ctx.reply('Ваш аккаунт заблокирован.');
        }
      } catch (error: any) {
        log('error', `Ошибка обработки команды /start: ${error.message}`, payload);
      }
    });

    // Обработка callback‑запросов
    bot.on('callback_query:data', async (ctx) => {
      if (!ctx.callbackQuery || !ctx.callbackQuery.data) return;
      try {
        const data = ctx.callbackQuery.data;
        const parts = data.split('|');
        const cbType = parts[0]?.trim() ?? '';
        const callbackAlias = parts[1]?.trim() ?? '';

        // Если callback типа "layout" и alias равен "go_back_state", перенаправляем в goBackState
        if (cbType === 'layout' && callbackAlias === 'go_back_state') {
          await goBackState(ctx, payload, botConfig);
        }
        // Обработка типов, связанных с каталогом
        else if (cbType === 'catalogCategory' || cbType === 'catalogLoadMore') {
          await handleCatalogEvent(cbType, callbackAlias, '', ctx, payload);
          log('info', `Callback "${cbType}|${callbackAlias}" обработан через handleCatalogEvent.`, payload);
        }
        else {
          switch (cbType) {
            case 'layout': {
              const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === callbackAlias);
              if (layoutBlock) {
                ctx.session.previousState = layoutBlock;
                await sendLayoutBlock(ctx, botConfig, payload, callbackAlias);
              } else {
                await ctx.reply(`Ошибка: Лейаут с alias "${callbackAlias}" не найден.`);
              }
              break;
            }
            case 'message': {
              await processMessageBlock(ctx, { message: callbackAlias });
              log('info', `MessageBlock "${callbackAlias}" успешно обработан.`, payload);
              break;
            }
            case 'command': {
              if (callbackAlias === 'go_back_state') {
                await goBackState(ctx, payload, botConfig);
              } else {
                await ctx.reply(`Неизвестная команда: ${callbackAlias}`);
              }
              break;
            }
            default: {
              await ctx.reply(`Неизвестный тип callback: ${cbType}`);
            }
          }
        }
        await ctx.answerCallbackQuery();
      } catch (error: any) {
        log('error', `Ошибка обработки callback_query: ${error.message}`, payload);
      }
    });

    bot.start();
    log('info', `🤖 Бот "${botConfig.name}" успешно запущен.`, payload);

    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: {
        initialization_status: 'Initialized',
        last_initialized: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    log('error', `Ошибка при инициализации бота "${botConfig.name}": ${error.message}`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: { initialization_status: 'Error' },
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/BotConfig.ts
// Version: 1.4.0-stable+goBack_fix
//
// [CHANGELOG]
// - Обновлён конструктор для гарантии наличия свойства interface с дефолтными значениями.
import type { UnifiedBotConfig, UnifiedBotInterface } from './initializeBots';

const defaultInterface: UnifiedBotInterface = {
  blocks: [],
  defaultStartLayout: 'start',
  defaultFirstVisitLayout: 'start_first_visit',
  total_visit: 0,
};

export class BotConfig {
  public id: number;
  public name: string;
  public token: string;
  public description?: string;
  public enabled: string;
  public initialization_status: string;
  public last_initialized?: string;
  public interface: UnifiedBotInterface;

  constructor(data: UnifiedBotConfig) {
    this.id = data.id;
    this.name = data.name;
    this.token = data.token;
    this.description = data.description;
    this.enabled = data.enabled;
    this.initialization_status = data.initialization_status;
    this.last_initialized = data.last_initialized;
    // Объединяем переданные данные с дефолтными значениями
    this.interface = {
      blocks: data.interface?.blocks ?? defaultInterface.blocks,
      defaultStartLayout: data.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: data.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit:
        typeof data.interface?.total_visit === 'number'
          ? data.interface.total_visit
          : defaultInterface.total_visit,
    };
  }

  get telegramApiToken(): string {
    return this.token;
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/goBackState.ts
// Version: 1.0.2-goBack_fix
//
// [CHANGELOG]
// - Реализована навигация "назад" с использованием поля previousState из сессии.
// - Если предыдущее состояние найдено, вызывается sendLayoutBlock с alias предыдущего состояния.
// - Если предыдущего состояния нет, выводится сообщение об ошибке.
import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';

export async function goBackState(ctx: BotContext, payload: Payload, botConfig: any): Promise<void> {
    try {
        if (!ctx.session.previousState) {
            await ctx.reply('Предыдущее состояние не найдено.');
            return;
        }
        // Используем alias предыдущего состояния
        const previousAlias = ctx.session.previousState.alias;
        await sendLayoutBlock(ctx, botConfig, payload, previousAlias);
        log('info', 'Команда go_back_state выполнена успешно. Пользователь возвращён к предыдущему состоянию.', payload);
    } catch (error: any) {
        log('error', `Ошибка выполнения команды go_back_state: ${error.message}`, payload);
        await ctx.reply('Ошибка при возврате в предыдущее состояние.');
    }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages.ts
// Version: 1.3.5-goBack_fix
//
// [CHANGELOG]
// - Обновлён тип SessionData: добавлены stateStack, previousState и isBanned для поддержки go_back_state.
import type { Context, SessionFlavor } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export interface SessionData {
  previousMessages: number[];
  stateStack: any[];
  previousState?: any;
  isBanned: boolean;
}

export type BotContext = Context & SessionFlavor<SessionData>;

export async function clearPreviousMessages(ctx: BotContext): Promise<void> {
  if (!ctx.chat || !ctx.session || !Array.isArray(ctx.session.previousMessages)) {
    log('debug', 'Контекст чата или данные сессии недоступны.');
    return;
  }
  const chatId = ctx.chat.id;
  const messageIds = ctx.session.previousMessages;
  try {
    for (const msgId of messageIds) {
      try {
        await ctx.api.editMessageReplyMarkup(chatId, msgId, { reply_markup: undefined });
      } catch (error: any) {}
      try {
        await ctx.api.deleteMessage(chatId, msgId);
      } catch (error: any) {}
    }
  } catch (err: any) {
  } finally {
    ctx.session.previousMessages = [];
  }
}

export function storeMessageId(ctx: BotContext, messageId: number): void {
  if (!messageId) return;
  if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
    ctx.session.previousMessages.push(messageId);
  }
}
// 📌 Путь: src/plugins/TelegramAPI/utils/SystemUtils/Logger.ts
// 📌 Версия: 1.1.0
//
// [CHANGELOG]
// - Восстановлен импорт `Payload` для устранения ошибки компиляции.
// - Актуализированы комментарии и добавлена проверка на корректность экземпляра `Payload`.
// - Улучшена обработка ошибок в блоке Payload CMS логирования.

import type { Payload } from 'payload';

/**
 * Функция логирования.
 * @param {string} level - Уровень логирования ('info', 'debug', 'error').
 * @param {string} message - Сообщение для логирования.
 * @param {Payload} [payload] - Экземпляр Payload CMS для записи лога.
 * @param {Record<string, any>} [context] - Дополнительные данные для логирования (например, объект контекста).
 */
export function log(
  level: 'info' | 'debug' | 'error',
  message: string,
  payload?: Payload,
  context?: Record<string, any>
): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

  // Вывод в консоль
  if (context && Object.keys(context).length > 0) {
    console.log(logMessage, context);
  } else {
    console.log(logMessage);
  }

  // Вывод через Payload CMS, если доступно
  if (payload?.logger && typeof payload.logger[level] === 'function') {
    try {
      payload.logger[level](message, context || {});
    } catch (err: any) {
      console.error(
        `[${timestamp}] [ERROR] Ошибка логирования через Payload CMS: ${err.message || 'Неизвестная ошибка'}`
      );
    }
  }
}
// Path: src/plugins/TelegramAPI/types/TelegramBlocksTypes.ts
// Version: 1.1.3
export enum BlockType {
  Layout = 'layout-blocks',
  Catalog = 'catalog-blocks',
  Message = 'message-blocks',
  Button = 'button-blocks',
  Command = 'command-blocks',
}

export interface TelegramLayoutBlock {
  blockType: BlockType.Layout;
  name: string;
  alias: string;
  blocks: TelegramSubBlock[];
  clearPreviousMessages?: boolean;
}

export interface TelegramCatalogBlock {
  blockType: BlockType.Catalog;
  name: string;
  alias: string;
  itemsPerPage?: number;
}

export interface TelegramMessageBlock {
  blockType: BlockType.Message;
  text: string;
}

export interface TelegramButtonBlock {
  blockType: BlockType.Button;
  text: string;
  callbackType: 'link' | 'message' | 'layout' | 'command';
}

export interface TelegramCommandBlock {
  blockType: BlockType.Command;
  command: string;
  responseText: string;
}

export type TelegramSubBlock =
  | TelegramLayoutBlock
  | TelegramCatalogBlock
  | TelegramMessageBlock
  | TelegramButtonBlock
  | TelegramCommandBlock;
