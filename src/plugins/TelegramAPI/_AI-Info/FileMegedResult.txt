–ö–æ–¥ –≤ —ç—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ - —Å—á–∏—Ç–∞–µ—Ç—Å—è –°–¢–ê–ë–ò–õ–¨–ù–û–ô-–†–ê–ë–û–ß–ï–ô –≤–µ—Ä—Å–∏–µ–π, –º—ã –±—É–¥–µ–º –µ—ë –¥–æ—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª. 

–Ω–∞–º –Ω—É–∂–Ω–æ –ø—Ä–æ–¥—É–º–∞—Ç—å –∫–∞–∫ –æ–±–µ–∑–æ–ø–∞—Å–∏—Ç—å –ø–ª–∞–≥–∏–Ω –ø—Ä–∏ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö, –ø–æ–ø—ã—Ç–æ–∫ –∏—Å–ø–æ–ª—å–Ω–∏—Ç—å –∫–æ–¥ –∏–ª–∏ –ø—Ä–æ–≤–µ—Å—Ç–∏ sql –∏–Ω—å–µ–∫—Ü–∏—é:
1. –ü—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤—ã–≤–æ–¥–∏–º –µ–º—É —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–Ω–∏–∏ –±–æ—Ç–æ–º –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
2. –†–µ–∞–ª—å–Ω–æ –Ω–µ –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∏ –Ω–µ –æ–±—Ä–∞–±—ã–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
3. –ù–µ –≤—ã–≤–æ–¥–∏—Ç—å –≤ –¥–∏–∞–ª–æ–≥–µ –±–æ—Ç–∞ –∏–ª–∏ —Å—Ä–∞–∑—É —É–¥–∞–ª—è—Ç—å –∏—Ö, –æ—Ç–ø—Ä–∞–≤–ª—è—è –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ–± –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–∏
4. —Å–æ–∑–¥–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –±–µ–∑–æ–ø–∞—Å—Ç–Ω–æ—Å—Ç–∏, –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –∞—Ç–∞–∫.
5. –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Ä–µ—à–µ–Ω–∏–µ –ø–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–º—É —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—é —Ä–µ–µ—Å—Ç—Ä–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–ª–æ–∫–æ–≤ –∏ –∏—Ö –∫–æ–ª–±—ç–∫–æ–≤.

(–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞, —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏: 
1. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
–ë–æ—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω –Ω–∞ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ—Å–ª–µ –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∫–∏. –î–ª—è —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–µ—Ç–æ–¥ deleteMessage –∏–∑ Telegram Bot API.

–ö–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å:

–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –±–æ—Ç–∞ –Ω–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.

–î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—ã–∑–æ–≤–∏—Ç–µ deleteMessage, –ø–µ—Ä–µ–¥–∞–≤ chat_id –∏ message_id 13.

–í–∞–∂–Ω–æ: –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å –ø—Ä–∞–≤–∞ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ. –í –ª–∏—á–Ω–æ–º –¥–∏–∞–ª–æ–≥–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —ç—Ç–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. )

–ü—Ä–µ–¥–ª–æ–∂–∏ —Ä–µ—à–µ–Ω–∏–µ. 


-------------------------

–ò–ù–°–¢–†–£–ö–¶–ò–ò. –ó–ê–ü–û–ú–ù–ò - –í–ê–ñ–ù–û!
1. –í—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–π –ø—É—Ç–∏ –¥–æ —Ñ–∞–π–ª–æ–≤
2. –ü–æ–¥—Ä–æ–±–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç—Ä–∞–∏–∏ –≤ –∫–æ–¥–µ
3. –ü–æ–º–Ω–∏ –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞
4. –ó–∞–ø–æ–º—è–Ω–∞–π –≤—Å–µ –æ—à–∏–±–∫–∏ –∏ —Ä–µ—à–µ–Ω–∏—è –∫ –Ω–∏–º.
5. –í –∫–æ–º–µ–Ω—Ç–∞—Ä–∏—è—Ö –∫–æ–¥–∞ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—É—Ç—å –¥–æ —Ñ–∞–π–ª–∞ –æ—Ç –∫–æ—Ä–Ω—è. 
6. –ö–∞–∂–¥—ã–π —Ñ–∞–π–ª –ø–æ–º–µ—á–∞–π –∫–æ–º–µ–Ω—Ç–∞–º–∏ –≤–µ—Ä—Å–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
7. –∏—Å—Ç—Ä—É–∫–∏—è –ø–æ —à–∞–≥–∞–º.
8. –ó–∞–≤–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã, –∑–∞–ø–æ–º—è–Ω–∞–π –æ—Ç–≤–µ—Ç—ã –Ω–∞ –Ω–∏—Ö
9. –û—Ç–≤–µ—á–∞–π –≤—Å–µ–≥–¥–∞ –ø–æ —Ä—É—Å—Å–∫–∏
10. –ù–µ —É–¥–∞–ª—è–π —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª, –º—ã –¥–æ—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞
11. –ú–µ—Å—Ç–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞ –ø–æ–º–µ—á–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏
12. –ø—Ä–æ—Å—Ç–∞–≤–ª—è–µ–º TODO —Ç–∞–º –≥–¥–µ —ç—Ç–æ –Ω–µ–±–æ—Ö–æ–¥–∏–º–æ.
13. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–æ–¥ —Ñ–∞–π–ª–æ–≤ –≤ —Å–≤—è–∑–∫–µ, –Ω–µ –¥–æ–ø—É—Å–∫–∞–π –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–≥–∏–∫–∏ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞.
14. –ü—Ä–∏–¥–µ—Ä–∂–∏–≤–∞–π—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–≤ Payloadcms 3 –∏ grammyjs

–ó–∞–ø–æ–º–Ω–∏ —ç—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ —á—ë—Ç–∫–æ —Å–ª–µ–¥—É–π –∏–º –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏–π.
–ó–∞—Ä–∞–Ω–∏–µ –±–ª–∞–≥–æ–¥–∞—Ä—é!

-------------------------

// Path: src/plugins/TelegramAPI/index.TelegramAPI.ts
// Version: 5.7.0
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞ initializeBots.ts.
// –ö–æ–ª–ª–µ–∫—Ü–∏–∏ Bots –∏ Clients —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç—Å—è –≤ –ø–ª–∞–≥–∏–Ω–µ.
import type { Payload, Config, Plugin } from 'payload';
import Bots from '@/collections/TelegramAPI/Bots';
import Clients from '@/collections/TelegramAPI/Clients';
import { initializeBots } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const TelegramAPIPlugin: Plugin = (incomingConfig: Config): Config => {
  return {
    ...incomingConfig,
    collections: [
      ...(incomingConfig.collections || []),
      Bots,
      Clients,
    ],
    onInit: async (payload: Payload) => {
      log('info', 'TelegramAPIPlugin initialization started.', payload);
      await initializeBots(payload);
      log('info', 'TelegramAPIPlugin initialized successfully.', payload);
    },
  };
};

export default TelegramAPIPlugin;
// Path: src/plugins/TelegramAPI/utils/ClientUtils/processClient.ts
// Version: 1.3.9-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –£–¥–∞–ª–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ FromData, –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ TelegramBlocksTypes.ts.
// –ü–æ–ª—è telegramId –∏ botId –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è —á–∞—Å—Ç—å—é –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª—è Telegram.

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–∞ FromData –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ —Å —Ç–∏–ø–∞–º–∏
import type { FromData } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function processClient(
  payload: Payload,
  telegramId: number,
  botId: number,
  fromData: FromData
): Promise<any> {
  try {
    log('info', `[processClient] Searching for client with telegram_id=${telegramId} and bot=${botId}`, payload);

    const { docs } = await payload.find({
      collection: 'clients',
      where: { telegram_id: { equals: telegramId } },
      limit: 1,
    });

    let client: any;

    if (!docs || docs.length === 0) {
      log('info', "[processClient] No existing client found, creating a new one...", payload);
      client = await payload.create({
        collection: 'clients',
        data: {
          telegram_id: telegramId,                   // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram
          bots: [botId],                             // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±–æ—Ç–∞
          first_name: fromData.first_name ?? "",
          last_name: fromData.last_name ?? "",
          user_name: fromData.username || 'anonymous_user',
          total_visit: 1,                            // –ü–µ—Ä–≤–æ–µ –ø–æ—Å–µ—â–µ–Ω–∏–µ
          last_visit: new Date().toISOString(),      // –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –∫–∞–∫ –¥–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–∏–∑–∏—Ç–∞
          enabled: "enabled"
          // –ü–æ–ª–µ status –Ω–µ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è, —á—Ç–æ–±—ã –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å —á–µ—Ä–µ–∑ defaultValue –∏–ª–∏ beforeChange-—Ö—É–∫ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏.
        },
      });
    } else {
      const existingClient = docs[0]!;
      log('info', `[processClient] Client found: ID=${existingClient.id}`, payload);
      let botsArray: any[] = Array.isArray(existingClient.bots)
        ? existingClient.bots
        : existingClient.bots ? [existingClient.bots] : [];
      if (!botsArray.some(b =>
        b != null && typeof b === 'object'
          ? b.id !== undefined && b.id.toString() === botId.toString()
          : b != null && b.toString() === botId.toString()
      )) {
        botsArray.push(botId);
        log('info', `[processClient] Bot ${botId} added to client ${existingClient.id}`, payload);
      }
      client = await payload.update({
        collection: 'clients',
        id: existingClient.id,
        data: {
          bots: botsArray,
          first_name: fromData.first_name ?? existingClient.first_name ?? "",
          last_name: fromData.last_name ?? existingClient.last_name ?? "",
          user_name: fromData.username || existingClient.user_name || 'anonymous_user',
          last_visit: new Date().toISOString(),
          total_visit: (existingClient.total_visit ?? 0) + 1,
        },
      });
    }

    log('debug', `[processClient] Client status: ${client.status}`, payload);
    const statusAlias = await checkClientStatus(payload, client.status);
    log('debug', `[processClient] Retrieved status alias: ${statusAlias}`, payload);
    const isBanned = statusAlias === 'banned';

    if (isBanned) {
      log('info', `[processClient] Client ID=${client.id} is banned. Updating status...`, payload);
      client = await payload.update({
        collection: 'clients',
        id: client.id,
        data: {
          enabled: "disabled",
        },
      });
      client.isBanned = true;
    } else {
      client.isBanned = false;
    }

    return client;
  } catch (error: any) {
    log('error', `[processClient] Error processing client: ${error.message}`, payload);
    return { total_visit: 1 };
  }
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/checkClientStatus.ts
// Version: 1.1.5-stable
//
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —á–∏—Å–ª–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–æ–ª–µ status.
// - –ï—Å–ª–∏ status —Ä–∞–≤–µ–Ω undefined –∏–ª–∏ null, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è "new" –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
// - –ï—Å–ª–∏ status ‚Äì –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º alias, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è alias; –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å ‚Äì —á–∏—Å–ª–æ –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∑–∞–ø—Ä–æ—Å –∫ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "statuses".
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function checkClientStatus(
  payload: Payload,
  status: any
): Promise<string | null> {
  try {
    if (status === undefined || status === null) {
      log('debug', 'checkClientStatus: status is undefined or null, defaulting to "new"');
      return "new";
    }
    if (typeof status === 'object') {
      if ('alias' in status && typeof status.alias === 'string') {
        return status.alias;
      }
      if ('id' in status) {
        const statusResult = await payload.find({
          collection: 'statuses',
          where: { id: { equals: status.id } },
          limit: 1,
        });
        const statusDoc = statusResult.docs[0];
        return statusDoc?.alias || "new";
      }
    }
    if (typeof status === 'number' || typeof status === 'string') {
      const statusResult = await payload.find({
        collection: 'statuses',
        where: { id: { equals: status } },
        limit: 1,
      });
      const statusDoc = statusResult.docs[0];
      return statusDoc?.alias || "new";
    }
  } catch (error: any) {
    log('error', `‚ùå –û—à–∏–±–∫–∞ –≤ checkClientStatus: ${error.message}`, payload);
  }
  return "new";
}
// Path: src/plugins/TelegramAPI/utils/ClientUtils/bannedClient.ts
// Version: 1.2.3-stable
//
// [CHANGELOG]
// - –û–±—ä–µ–¥–∏–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–Ω–∞ –≤ –æ–¥–∏–Ω middleware.
// - –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Å–µ—Å—Å–∏–æ–Ω–Ω—ã–π —Ñ–ª–∞–≥ isBanned; –µ—Å–ª–∏ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –¥–∞–ª—å–Ω–µ–π—à–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è.
// - –ï—Å–ª–∏ —Ñ–ª–∞–≥ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ checkClientStatus.
// - –ï—Å–ª–∏ alias —Ä–∞–≤–µ–Ω "banned", –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Ñ–ª–∞–≥ isBanned —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ —Å–µ—Å—Å–∏–∏.
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä log –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
import type { Context } from 'grammy';
import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { checkClientStatus } from './checkClientStatus';

export function bannedClientHook(payload: Payload) {
  return async (ctx: Context & { session: any }, next: () => Promise<void>): Promise<void> => {
    try {
      if (ctx.session.isBanned) {
        await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
        log('info', 'bannedClientHook: Session indicates client is banned, skipping processing.', payload);
        return;
      }
      if (ctx.from) {
        const telegramId = ctx.from.id;
        const { docs } = await payload.find({
          collection: 'clients',
          where: { telegram_id: { equals: telegramId } },
          limit: 1,
        });
        const client = docs.length > 0 ? docs[0] : null;
        if (client && client.status) {
          const statusAlias = await checkClientStatus(payload, client.status);
          if (statusAlias === 'banned') {
            await ctx.reply("üíÄ Your account is locked! üíÄ \n\nüö∑ You've been banned.");
            log('info', `bannedClientHook: Client ID=${client.id} is banned according to DB check.`, payload);
            ctx.session.isBanned = true;
            return;
          }
        }
      }
      await next();
    } catch (error: any) {
      log('error', `bannedClientHook: Error checking ban status: ${error.message}`, payload);
      await next();
    }
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock.ts
// Version: 1.3.8-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±—â–µ–≥–æ —Ç–∏–ø–∞ TelegramLayoutBlock –∏ BotContext –∏–∑ —Ñ–∞–π–ª–∞ TelegramBlocksTypes.ts.
// –õ–æ–∫–∞–ª—å–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ LayoutBlock —É–¥–∞–ª–µ–Ω–æ. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–æ–≤ –æ—Å—Ç–∞—ë—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.
// –î–æ–±–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤ —Å—Ç–µ–∫ (stateStack) –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º –Ω–∞ –Ω–æ–≤—ã–π layout.

import type { Payload } from 'payload';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–æ–≤ –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ —Å —Ç–∏–ø–∞–º–∏
import type { BotContext, TelegramLayoutBlock } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
import { handleButtonBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const blockHandlers: Record<string, (ctx: BotContext, block: any, payload: Payload) => Promise<void>> = {
  messageblock: processMessageBlock,
  'message-blocks': processMessageBlock,
  buttonblock: async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  'button-blocks': async (ctx, block, payload) => {
    const description = block.description || '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
    await handleButtonBlock(ctx, block, description);
  },
  catalogblock: renderCatalogBlock,
  'catalog-blocks': renderCatalogBlock,
};

export async function sendLayoutBlock(
  ctx: BotContext,
  botConfig: any, // –û–∂–∏–¥–∞–µ—Ç—Å—è –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ BotConfig
  payload: Payload,
  aliasOverride?: string
): Promise<void> {
  // –ï—Å–ª–∏ aliasOverride –Ω–µ –∑–∞–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ botConfig.interface.defaultStartLayout
  const layoutAlias = aliasOverride ?? botConfig.interface?.defaultStartLayout;

  if (!layoutAlias) {
    await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
    return;
  }

  try {
    log('debug', `–ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π layoutAlias: ${layoutAlias}`);
    log('debug', `BotConfig.interface: ${JSON.stringify(botConfig.interface)}`);

    // –ï—Å–ª–∏ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –µ–≥–æ alias –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –Ω–æ–≤–æ–≥–æ, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ –≤ —Å—Ç–µ–∫
    if (ctx.session.currentState && ctx.session.currentState.alias !== layoutAlias) {
      ctx.session.stateStack.push(ctx.session.currentState);
    }

    // –ï—Å–ª–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –±–ª–æ–∫–æ–≤ –Ω–µ—Ç ‚Äì –≤—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º
    if (!botConfig.interface || !botConfig.interface.blocks || botConfig.interface.blocks.length === 0) {
      await ctx.reply(`Layout "${layoutAlias}" –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –±–ª–æ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      return;
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–µ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ TelegramLayoutBlock –≤–º–µ—Å—Ç–æ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ LayoutBlock
    const layoutBlock: TelegramLayoutBlock | undefined = botConfig.interface!.blocks.find(
      (block: any) => block.alias === layoutAlias
    );

    if (!layoutBlock) {
      const msg = await ctx.reply(`Layout "${layoutAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    ctx.session.currentState = layoutBlock;

    if (layoutBlock.clearPreviousMessages && ctx.chat) {
      log('debug', `–ü–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π LayoutBlock "${layoutBlock.name}" –æ—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è.`);
      await clearPreviousMessages(ctx);
    }

    if (!Array.isArray(layoutBlock.blocks) || layoutBlock.blocks.length === 0) {
      const msg = await ctx.reply(`Layout "${layoutBlock.name}" –ø—É—Å—Ç. –î–æ–±–∞–≤—å—Ç–µ –±–ª–æ–∫–∏.`);
      storeMessageId(ctx, msg.message_id);
      return;
    }

    for (const block of layoutBlock.blocks) {
      try {
        const blockType = block.blockType?.toLowerCase();
        const handler = blockHandlers[blockType];
        if (handler) {
          log('debug', `–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–ª–æ–∫ —Ç–∏–ø–∞ "${blockType}"`);
          await handler(ctx, block, payload);
        } else {
          log('error', `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${blockType}`, payload);
          const msg = await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –±–ª–æ–∫–∞: ${block.blockType}`);
          storeMessageId(ctx, msg.message_id);
        }
      } catch (blockError) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–∞: ${(blockError as Error).message}`, payload);
        const msg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–ª–æ–∫–∞: ${layoutBlock.name}`);
        storeMessageId(ctx, msg.message_id);
      }
    }
  } catch (error: any) {
    log('error', `–û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞ "${layoutAlias}": ${(error as Error).message}`, payload);
    const errorMsg = await ctx.reply(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–µ–π–∞—É—Ç–∞: "${layoutAlias}"`);
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/index.TelegramAPI.ts
// üìå –í–µ—Ä—Å–∏—è: 1.2.0
//
// [CHANGELOG]
// - –£–±—Ä–∞–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Ç–æ–≤–∞—Ä—ã –Ω–∞ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ `CatalogBlock`.
// - –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤—ã–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/utils/BotUtils/initializeBots';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

/**
 * –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ `CatalogBlock`.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} block - –ë–ª–æ–∫ –∫–∞—Ç–∞–ª–æ–≥–∞.
 * @param {Payload} payload - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS.
 */
export async function renderCatalogBlock(ctx: BotContext, block: any, payload: Payload): Promise<void> {
  try {
    if (!block || !ctx.chat) {
      throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–ª–æ–∫ –∏–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞.');
    }

    const inlineKeyboard = new InlineKeyboard();

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } }, // –¢–æ–ª—å–∫–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
      limit: 999,
    });

    const categories = categoriesResult.docs;

    // –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç
    if (categories.length === 0) {
      await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row(); // –ù–æ–≤—ã–π —Ä—è–¥ –∫–∞–∂–¥—ã–µ 2 –∫–Ω–æ–ø–∫–∏
    });

    // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–±–ª–æ–∂–∫–æ–π –∏ –æ–ø–∏—Å–∞–Ω–∏–µ–º
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';

    await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
    });

    log('info', `–ö–∞—Ç–∞–ª–æ–≥ —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂—ë–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItems.ts
// Version: 1.4.12-refactored
//
// [CHANGELOG]
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø—Ü–∏—è protect_content –≤–æ –≤—Å–µ—Ö –≤—ã–∑–æ–≤–∞—Ö ctx.reply –∏ ctx.replyWithPhoto,
//   —á—Ç–æ–±—ã –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–Ω–æ–π –∑–∞—â–∏—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è, –æ–ø–∏—Å–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –±—ã–ª–∏ –∑–∞—â–∏—â–µ–Ω—ã.
// - –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ —Ç–æ–≤–∞—Ä–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π –æ—Å—Ç–∞–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–µ–π.

import type { Payload } from 'payload';
import type { BotContext, RenderOptions } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { clearPreviousMessages, storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';

export async function renderCategoryItems(
  ctx: BotContext,
  categoryId: string,
  options: RenderOptions,
  payload: Payload,
  clearMessages: boolean = true
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }
    if (clearMessages) {
      await clearPreviousMessages(ctx);
    }
    const category = await payload.findByID({
      collection: 'product-categories',
      id: categoryId,
    });
    if (!category) {
      log('error', `–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å ID "${categoryId}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.`, payload);
      const msg = await ctx.reply('–û—à–∏–±–∫–∞: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.', {
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, msg.message_id);
      return;
    }
    const categoryMedia = Array.isArray(category.media) && category.media.length > 0
      ? category.media
      : [{ url: 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png' }];
    const categoryCaption = `<b>${category.name}</b>\n${category.description || ''}`;
    const categoryMsg = await ctx.replyWithPhoto(categoryMedia[0].url, {
      caption: categoryCaption,
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, categoryMsg.message_id);

    let subcategories: any[] = [];
    let products: any[] = [];

    if (options.displayMode === 'subcategories' || options.displayMode === 'all') {
      const subResult = await payload.find({
        collection: 'product-categories',
        where: { parent_id: { equals: categoryId } },
        limit: 999,
      });
      subcategories = subResult.docs;
    }

    let totalPages = 0;
    if (options.displayMode === 'products' || options.displayMode === 'all') {
      const productPagination = await paginateCategoryItems(
        payload,
        'products',
        { category_ids: { in: [parseInt(categoryId, 10)] } },
        options.page,
        options.itemsPerPage
      );
      products = productPagination.docs;
      totalPages = productPagination.totalPages;
    }

    if (subcategories.length === 0 && products.length === 0) {
      const emptyMessage = await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –ø—É—Å—Ç–∞. –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.', {
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, emptyMessage.message_id);
      return;
    }

    if (subcategories.length > 0 && (options.displayMode === 'subcategories' || options.displayMode === 'all')) {
      const subKeyboard = new InlineKeyboard();
      subcategories.forEach((subcat: any, index: number) => {
        subKeyboard.text(subcat.name, `catalogCategory|${subcat.id}`);
        if ((index + 1) % 2 === 0) subKeyboard.row();
      });
      const subMsg = await ctx.reply('–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏:', {
        reply_markup: subKeyboard,
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, subMsg.message_id);
    }

    if (products.length > 0 && (options.displayMode === 'products' || options.displayMode === 'all')) {
      for (const product of products) {
        await renderProductCard(ctx, product.id, payload);
      }
      if (options.page < totalPages) {
        const navKeyboard = new InlineKeyboard().text(
          "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë",
          `catalogLoadMore|${categoryId}|${options.page + 1}|${options.itemsPerPage}`
        );
        const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${options.page}`, {
          parse_mode: 'HTML',
          reply_markup: navKeyboard,
          protect_content: ctx.session.botConfig?.protectContent || false,
        });
        storeMessageId(ctx, navMsg.message_id);
      }
    }
    log('info', `–≠–ª–µ–º–µ–Ω—Ç—ã –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –¥–ª—è ID: ${categoryId}.`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: ${error.message}`, payload);
    const errorMsg = await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.', {
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, errorMsg.message_id);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/paginateCategoryItems.ts
// Version: 1.1.2
//
// [CHANGELOG]
// - –§—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª—è–º–∏ docs –∏ totalPages –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–∞–Ω–∏—Ü.
import type { Payload, CollectionSlug } from 'payload';

export async function paginateCategoryItems(
  payload: Payload,
  collection: CollectionSlug,
  where: Record<string, any>,
  page: number,
  itemsPerPage: number,
): Promise<{ docs: any[]; totalPages: number }> {
  try {
    const result = await payload.find({
      collection,
      where,
      limit: itemsPerPage,
      page,
      sort: 'name',
    });
    return {
      docs: result.docs || [],
      totalPages: result.totalPages || Math.ceil((result.totalDocs || 0) / itemsPerPage),
    };
  } catch (error: any) {
    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}":`, error);
    throw new Error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "${collection}".`);
  }
}

export function generatePaginationData(
  currentPage: number,
  totalItems: number,
  itemsPerPage: number,
): {
  currentPage: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
} {
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  return {
    currentPage,
    totalPages,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
  };
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCategoryItemsLoadMore.ts
// Version: 1.0.40-refactored
//
// [CHANGELOG]
// - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è paginateCategoryItems, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç totalPages.
// - –ï—Å–ª–∏ —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–∞–≤–Ω–∞ totalPages, –∫–Ω–æ–ø–∫–∞ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë" –Ω–µ –≤—ã–≤–æ–¥–∏—Ç—Å—è.
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø—Ü–∏—è protect_content –≤–æ –≤—Å–µ—Ö –≤—ã–∑–æ–≤–∞—Ö ctx.reply/ctx.replyWithPhoto.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { paginateCategoryItems } from './paginateCategoryItems';
import { renderProductCard } from './renderProductCard';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

const DEMO_PRODUCT_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderCategoryItemsLoadMore(
  ctx: BotContext,
  categoryId: string,
  payload: Payload,
  page: number,
  itemsPerPage: number = 3
): Promise<void> {
  try {
    log('info', `–ü–æ–¥–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä—ã –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${categoryId}, —Å—Ç—Ä–∞–Ω–∏—Ü–∞ ${page}, itemsPerPage=${itemsPerPage}`, payload);
    const productPagination = await paginateCategoryItems(
      payload,
      'products',
      { category_ids: { in: [categoryId] } },
      page,
      itemsPerPage
    );
    const products = productPagination.docs;
    const totalPages = productPagination.totalPages;
    if (!products || products.length === 0) {
      const noMoreMsg = await ctx.reply("–ù–µ—Ç –±–æ–ª—å—à–µ —Ç–æ–≤–∞—Ä–æ–≤.", {
        parse_mode: 'HTML',
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, noMoreMsg.message_id);
      log('info', `–¢–æ–≤–∞—Ä—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${categoryId}`, payload);
      return;
    }
    for (const product of products) {
      await renderProductCard(ctx, product.id, payload);
    }
    if (page < totalPages) {
      const navKeyboard = new InlineKeyboard().text(
        "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë",
        `catalogLoadMore|${categoryId}|${page + 1}|${itemsPerPage}`
      );
      const navMsg = await ctx.reply(`–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${page}`, {
        parse_mode: 'HTML',
        reply_markup: navKeyboard,
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, navMsg.message_id);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –≤ renderCategoryItemsLoadMore: ${error.message}`, payload);
    await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥—Ä—É–∑–∫–µ —Ç–æ–≤–∞—Ä–æ–≤.", {
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers.ts
// Version: 1.2.7-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –û–±–Ω–æ–≤–ª–µ–Ω—ã –∏–º–ø–æ—Ä—Ç—ã —Ç–∏–ø–æ–≤ –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ TelegramBlocksTypes.ts.
// –õ–æ–∫–∞–ª—å–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ RenderOptions —É–¥–∞–ª–µ–Ω–æ.

import type { Payload } from 'payload';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–æ–≤ –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞
import type { BotContext, RenderOptions } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { renderCategoryItems } from './renderCategoryItems';
import { renderCategoryItemsLoadMore } from './renderCategoryItemsLoadMore';

export async function handleCatalogEvent(
  cbType: string,
  _unused: string, // –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—É–¥—É—Ç –∏–∑–≤–ª–µ—á–µ–Ω—ã –∏–∑ callback –¥–∞–Ω–Ω—ã—Ö
  _unused2: string | undefined,
  ctx: BotContext,
  payload: Payload,
): Promise<void> {
  try {
    if (!ctx.callbackQuery || !ctx.callbackQuery.data) {
      throw new Error('–î–∞–Ω–Ω—ã–µ callback –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
    }
    const parts = (ctx.callbackQuery.data as string).split('|');
    const eventType = parts[0]?.trim() ?? '';
    if (eventType === 'catalogCategory') {
      // –î–ª—è catalogCategory –æ–∂–∏–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç: "catalogCategory|<categoryId>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawItemsPerPage = parts[2]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: "${rawCategoryId}".`, payload);
        await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
        return;
      }
      const options: RenderOptions = {
        page: 1,
        itemsPerPage,
        displayMode: "all", // –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏, –µ—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è
      };
      // –ü—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤ –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –æ—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
      await renderCategoryItems(ctx, categoryId.toString(), options, payload, true);
    } else if (eventType === 'catalogLoadMore') {
      // –î–ª—è catalogLoadMore –æ–∂–∏–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç: "catalogLoadMore|<categoryId>|<nextPage>|<itemsPerPage>"
      const rawCategoryId = parts[1]?.trim() ?? '';
      const rawPageValue = parts[2]?.trim() ?? "1";
      const rawItemsPerPage = parts[3]?.trim() ?? "3";
      const itemsPerPage = parseInt(rawItemsPerPage, 10) || 3;
      const nextPage = parseInt(rawPageValue, 10);
      const categoryId = parseInt(rawCategoryId, 10);
      if (isNaN(categoryId)) {
        log('error', `–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: "${rawCategoryId}".`, payload);
        await ctx.reply('–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
        return;
      }
      const options: RenderOptions = {
        page: nextPage,
        itemsPerPage,
        displayMode: "all",
      };
      // –ü—Ä–∏ –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–µ –Ω–µ –æ—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
      await renderCategoryItemsLoadMore(ctx, categoryId.toString(), payload, nextPage, itemsPerPage);
    } else {
      await ctx.reply('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞.');
      log('error', `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞: ${eventType}`, payload);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞: ${error.message}`, payload);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–±—ã—Ç–∏—è.');
  }
}
// Path: src/blocks/TelegramAPI/CatalogBlock/renderCatalogBlock.ts
// Version: 1.4.3-refactored
//
// [CHANGELOG]
// - –§–æ—Ä–º–∞—Ç callback‚Äë–¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: "catalogCategory|<categoryId>|<itemsPerPage>".
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø—Ü–∏—è protect_content, –µ—Å–ª–∏ –±–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –∑–∞—â–∏—Ç—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

export async function renderCatalogBlock(
  ctx: BotContext,
  block: any,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }
    const categoriesResult = await payload.find({
      collection: 'product-categories',
      where: { parent_id: { equals: null } },
      limit: 999,
    });
    const categories = categoriesResult.docs;
    if (categories.length === 0) {
      const emptyMsg = await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.');
      storeMessageId(ctx, emptyMsg.message_id);
      log('info', '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.', payload);
      return;
    }
    const inlineKeyboard = new InlineKeyboard();
    const itemsPerPage = block.itemsPerPage ?? 3;
    categories.forEach((category: any, index: number) => {
      inlineKeyboard.text(category.name, `catalogCategory|${category.id}|${itemsPerPage}`);
      if ((index + 1) % 2 === 0) inlineKeyboard.row();
    });
    const bannerUrl = block.banner || 'https://kvartiry-tbilisi.ru/images/demo/catalog_banner-1.png';
    const description = block.description || '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:';
    const catalogMsg = await ctx.replyWithPhoto(bannerUrl, {
      caption: description,
      parse_mode: 'HTML',
      reply_markup: inlineKeyboard,
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, catalogMsg.message_id);
    log('info', `–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ CatalogBlock —É—Å–ø–µ—à–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è CatalogBlock: ${error.message}`, payload);
    const errorMsg = await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–∞–ª–æ–≥–∞.');
    if (errorMsg?.message_id) {
      storeMessageId(ctx, errorMsg.message_id);
    }
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderProductCard.ts
// Version: 1.0.13-refactored
//
// [CHANGELOG]
// - –£–¥–∞–ª—ë–Ω –≤—ã–∑–æ–≤ clearPreviousMessages(ctx).
// - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø—Ü–∏—è protect_content –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è, –µ—Å–ª–∏ –±–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –∑–∞—â–∏—Ç—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞.

import type { Payload } from 'payload';
import { InlineKeyboard } from 'grammy';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';

const DEMO_IMAGE_URL = "https://kvartiry-tbilisi.ru/images/demo/product_banner.png";

export async function renderProductCard(
  ctx: BotContext,
  productId: string,
  payload: Payload
): Promise<void> {
  try {
    if (!ctx.chat) {
      log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', payload);
      return;
    }
    const result = await payload.find({
      collection: 'products',
      where: { id: { equals: productId } },
      limit: 1,
    });
    const product = result.docs[0];
    if (!product) {
      const msg = await ctx.reply("–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", {
        parse_mode: 'HTML',
        protect_content: ctx.session.botConfig?.protectContent || false,
      });
      storeMessageId(ctx, msg.message_id);
      log('error', `–ü—Ä–æ–¥—É–∫—Ç —Å ID ${productId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`, payload);
      return;
    }
    const { name, price, description } = product as any;
    let messageText = `<b>${name}</b>\n<b>–¶–µ–Ω–∞:</b> $${price}\n`;
    messageText += `<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> ${description || '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è'}\n`;
    const keyboard = new InlineKeyboard()
      .text("–ù–∞–∑–∞–¥", `catalogBack|${productId}`)
      .text("–ó–∞–∫–∞–∑–∞—Ç—å", `order|${productId}`);
    const cardMsg = await ctx.replyWithPhoto(DEMO_IMAGE_URL, {
      caption: messageText,
      parse_mode: 'HTML',
      reply_markup: keyboard,
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
    storeMessageId(ctx, cardMsg.message_id);
    log('info', `–ö–∞—Ä—Ç–æ—á–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∞ —Å ID ${productId} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.`, payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –ø—Ä–æ–¥—É–∫—Ç–∞: ${error.message}`, payload);
    await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–¥—É–∫—Ç–µ.", {
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/ButtonBlock/ButtonBlock.ts
// Version: 1.1.3-refactored
//
// [CHANGELOG]
// - –ï—Å–ª–∏ –ø–æ–ª–µ description –≤ ButtonBlock –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é "ButtonBlock".
// - –ï—Å–ª–∏ ButtonBlock –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ, —Ç–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è –≤—ã–≤–æ–¥–∏—Ç—Å—è –∫–∞–∫ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏.
// - –ï—Å–ª–∏ ButtonBlock —è–≤–ª—è–µ—Ç—Å—è –¥–æ—á–µ—Ä–Ω–∏–º –±–ª–æ–∫–æ–º MessageBlock, —É—Ç–∏–ª–∏—Ç–∞ MessageBlock –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { storeMessageId } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {BotContext} ctx - –ö–æ–Ω—Ç–µ–∫—Å—Ç Telegram –±–æ—Ç–∞.
 * @param {any} buttonBlock - –û–±—ä–µ–∫—Ç –∫–Ω–æ–ø–æ—á–Ω–æ–≥–æ –±–ª–æ–∫–∞.
 * @param {string} [defaultDescription] - –û–ø–∏—Å–∞–Ω–∏–µ –±–ª–æ–∫–∞ –∫–Ω–æ–ø–æ–∫, –µ—Å–ª–∏ –ø–æ–ª–µ description –Ω–µ –∑–∞–¥–∞–Ω–æ –≤ buttonBlock.
 */
export async function handleButtonBlock(
  ctx: BotContext,
  buttonBlock: any,
  defaultDescription = 'ButtonBlock'
): Promise<void> {
  if (!ctx.chat) {
    log('error', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.', undefined);
    return;
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–Ω–æ–ø–æ–∫
  if (!Array.isArray(buttonBlock.buttons) || buttonBlock.buttons.length === 0) {
    log('error', '–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–Ω–æ–ø–æ–∫.', undefined);
    const emptyMsg = await ctx.reply('–ö–Ω–æ–ø–æ—á–Ω—ã–π –±–ª–æ–∫ –ø—É—Å—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–Ω–æ–ø–∫–∏.');
    storeMessageId(ctx, emptyMsg.message_id);
    return;
  }

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑ buttonBlock, –µ—Å–ª–∏ –æ–Ω–æ –∑–∞–¥–∞–Ω–æ, –∏–Ω–∞—á–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
  const description = buttonBlock.description || defaultDescription;

  const inlineKeyboard = new InlineKeyboard();

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
  buttonBlock.buttons.forEach((btn: any) => {
    try {
      const callbackData = btn.callback_data || '';
      const buttonText = btn.text;

      switch (btn.callbackType) {
        case 'layout':
        case 'message':
        case 'command':
          inlineKeyboard.text(buttonText, `${btn.callbackType}|${callbackData}`);
          break;
        case 'link':
          inlineKeyboard.url(buttonText, btn.url || '');
          break;
        default:
          inlineKeyboard.text(buttonText, callbackData);
      }

      if (btn.newRow) {
        inlineKeyboard.row();
      }
    } catch (error: any) {
      log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–Ω–æ–ø–∫–∏: ${error.message}`, undefined);
    }
  });

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–∞–º–∏
  try {
    const buttonMsg = await ctx.reply(description, { reply_markup: inlineKeyboard });
    storeMessageId(ctx, buttonMsg.message_id);
    log('info', `–ö–Ω–æ–ø–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã. –°–æ–æ–±—â–µ–Ω–∏–µ ID: ${buttonMsg.message_id}`, undefined);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–Ω–æ–ø–æ–∫: ${error.message}`, undefined);
  }
}
// Path: src/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock.ts
// Version: 1.0.12-refactored
//
// This utility processes a MessageBlock by sending its content using HTML formatting via grammY.
// If a MessageBlock contains a "buttons" field (provided via ButtonBlock), the buttons are attached via an inline keyboard.
// Added option protect_content if the bot is configured to protect content.

import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { InlineKeyboard } from 'grammy';

function getTestMediaUrl(url: string): string {
  console.log(`[DEBUG] Overriding media URL for testing. Original URL: "${url}"`);
  return "https://kvartiry-tbilisi.ru/images/resize/medium/c77626871d5920df7195a89cc44a2c85.jpg";
}

function buildInlineKeyboard(buttons: any[]): InlineKeyboard {
  const keyboard = new InlineKeyboard();
  buttons.forEach((btn: any) => {
    const callbackType = btn.callbackType && btn.callbackType.trim() !== '' ? btn.callbackType : 'layout';
    const callbackData = btn.callback_data || '';
    const data = `${callbackType}|${callbackData}`;
    if (callbackType === 'link' && btn.url) {
      keyboard.url(btn.text, btn.url);
    } else {
      keyboard.text(btn.text, data);
    }
    if (btn.newRow) {
      keyboard.row();
    }
  });
  return keyboard;
}

export async function processMessageBlock(ctx: BotContext, blockData: any): Promise<void> {
  if (!ctx.chat) return;
  const text: string = blockData.text;
  try {
    const replyOptions: any = {
      parse_mode: 'HTML',
      protect_content: ctx.session.botConfig?.protectContent || false,
    };

    let buttonsArray: any[] = [];
    if (Array.isArray(blockData.buttons) && blockData.buttons.length > 0) {
      if (blockData.buttons[0]?.buttons) {
        blockData.buttons.forEach((btnBlock: any) => {
          if (Array.isArray(btnBlock.buttons)) {
            buttonsArray = buttonsArray.concat(btnBlock.buttons);
          }
        });
      } else {
        buttonsArray = blockData.buttons;
      }
      if (buttonsArray.length > 0) {
        replyOptions.reply_markup = buildInlineKeyboard(buttonsArray);
      }
    }

    let sentMsg;
    if (blockData.media && typeof blockData.media.url === 'string' && blockData.media.url.trim() !== "") {
      const mediaUrl = getTestMediaUrl(blockData.media.url);
      console.log(`[DEBUG] blockData.media:`);
      console.dir(blockData.media, { depth: null });
      console.log(`[DEBUG] Sending photo with test URL: "${mediaUrl}" and caption: "${text}"`);
      sentMsg = await ctx.replyWithPhoto(mediaUrl, {
        caption: text,
        ...replyOptions,
      });
    } else {
      sentMsg = await ctx.reply(text, replyOptions);
    }
    if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
      ctx.session.previousMessages.push(sentMsg.message_id);
      console.log(`[DEBUG] Stored message ID: ${sentMsg.message_id}. Current previousMessages: ${ctx.session.previousMessages}`);
    }
  } catch (error: any) {
    console.error('Error processing MessageBlock:', error);
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/initializeBots.ts
// Version: 1.4.7-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –û–±–Ω–æ–≤–ª–µ–Ω—ã –∏–º–ø–æ—Ä—Ç—ã —Ç–∏–ø–æ–≤ (BotContext, SessionData, UnifiedBotInterface) –∏–∑ –µ–¥–∏–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ TelegramBlocksTypes.ts,
// –¥–æ–±–∞–≤–ª–µ–Ω–æ —è–≤–Ω–æ–µ —É–∫–∞–∑–∞–Ω–∏–µ —Ç–∏–ø–∞ –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Å—Å–∏–∏ —Å –¥–≤—É–º—è —Ç–∏–ø–æ–≤—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏,
// –æ—Å—Ç–∞–≤–ª–µ–Ω—ã –æ—Ç–¥–µ–ª—å–Ω—ã–µ –≤—ã–∑–æ–≤—ã bot.use –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö middleware.
// –î–æ–±–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ–ø–∏—Å–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–∞ —ç—Ç–∞–ø–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–¥–æ –≤—ã–∑–æ–≤–∞ bot.start()).
// –¢–µ–ø–µ—Ä—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –±–æ—Ç—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö –ø–æ–ª–µ enabled –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ "enabled".
// –î–æ–±–∞–≤–ª–µ–Ω–æ –Ω–æ–≤–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ protectContent –≤ UnifiedBotConfig –∏ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –∏–∑ raw –¥–∞–Ω–Ω—ã—Ö.

import type { Payload } from 'payload';
import { Bot as TelegramBot, session } from 'grammy';

import { bannedClientHook } from '@/plugins/TelegramAPI/utils/ClientUtils/bannedClient';
import { processClient } from '@/plugins/TelegramAPI/utils/ClientUtils/processClient';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { processMessageBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/MessageBlock/MessageBlock';
import { renderCatalogBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/renderCatalogBlock';
import { handleCatalogEvent } from '@/plugins/TelegramAPI/utils/BlockUtils/CatalogBlock/CatalogEventHandlers';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';
import { goBackState } from '@/plugins/TelegramAPI/utils/SystemUtils/goBackState';
// –ò–º–ø–æ—Ä—Ç —Ç–∏–ø–æ–≤ –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞
import type { BotContext, SessionData, UnifiedBotInterface } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export type { BotContext };

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  protectContent?: boolean;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/**
 * –û–±—ä–µ–¥–∏–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –±–æ—Ç–∞ (–∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ Bots)
 * –≤ –µ–¥–∏–Ω—ã–π –æ–±—ä–µ–∫—Ç –Ω–∞—Å—Ç—Ä–æ–µ–∫ (UnifiedBotConfig). –ï—Å–ª–∏ rawBotData.interface –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç,
 * –µ–≥–æ –ø–æ–ª—è –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è —Å –Ω–∞–±–æ—Ä–æ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π; –µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äì –ø–æ–¥—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
 */
export function createUnifiedBotConfig(rawBotData: any): UnifiedBotConfig {
  const defaultInterface: UnifiedBotInterface = {
    blocks: [],
    defaultStartLayout: 'start',
    defaultFirstVisitLayout: 'start_first_visit',
    total_visit: 0,
  };
  return {
    id: rawBotData.id,
    name: rawBotData.name,
    token: rawBotData.token,
    description: rawBotData.description,
    enabled: rawBotData.enabled,
    protectContent: rawBotData.protectContent, // –ü–µ—Ä–µ–¥–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è protectContent –∏–∑ raw –¥–∞–Ω–Ω—ã—Ö
    initialization_status: rawBotData.initialization_status,
    last_initialized: rawBotData.last_initialized,
    interface: {
      blocks: Array.isArray(rawBotData.interface?.blocks) ? rawBotData.interface.blocks : defaultInterface.blocks,
      defaultStartLayout: rawBotData.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: rawBotData.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof rawBotData.interface?.total_visit === 'number'
        ? rawBotData.interface.total_visit
        : defaultInterface.total_visit,
    },
  };
}

export async function initializeBots(payload: Payload): Promise<void> {
  try {
    log('info', '–ü–æ–∏—Å–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ—Ç–æ–≤...', payload);
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –±–æ—Ç—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö enabled === "enabled"
    const { docs: bots } = await payload.find({
      collection: 'bots',
      where: { enabled: { equals: 'enabled' } },
      limit: 999,
    });
    log('info', `–ù–∞–π–¥–µ–Ω–æ ${bots.length} –±–æ—Ç–æ–≤ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.`, payload);

    for (const botData of bots) {
      const unifiedBotData = createUnifiedBotConfig(botData);
      if (unifiedBotData.enabled !== 'enabled') {
        log('info', `–ë–æ—Ç "${unifiedBotData.name}" –Ω–µ –≤–∫–ª—é—á—ë–Ω (enabled=${unifiedBotData.enabled}). –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é.`, payload);
        continue;
      }
      const botConfig = new BotConfig(unifiedBotData);

      console.log('BotConfig:', JSON.stringify(botConfig, null, 2));
      await initBot(payload, botConfig);
    }
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–æ–≤: ${error.message}`, payload);
  }
}

async function initBot(payload: Payload, botConfig: BotConfig): Promise<void> {
  try {
    if (!botConfig.token) {
      log('error', `–ü—Ä–æ–ø—É—â–µ–Ω –±–æ—Ç "${botConfig.name}": –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω.`, payload);
      return;
    }
    const bot = new TelegramBot<BotContext>(botConfig.token);

    bot.use(
      session<SessionData, BotContext>({
        initial: (): SessionData => ({
          previousMessages: [] as number[],
          stateStack: [] as any[],
          previousState: undefined,
          currentState: undefined,
          isBanned: false,
          botConfig: botConfig, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞ –≤ —Å–µ—Å—Å–∏–∏
        }),
      })
    );

    bot.use(bannedClientHook(payload));

    if (botConfig.description) {
      try {
        await bot.api.setMyDescription(botConfig.description);
        log('info', `–û–ø–∏—Å–∞–Ω–∏–µ –±–æ—Ç–∞ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.`, payload);
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ–ø–∏—Å–∞–Ω–∏—è –±–æ—Ç–∞: ${error.message}`, payload);
      }
    }

    bot.command('start', async (ctx) => {
      try {
        log('info', `–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from?.id}.`, payload);
        const telegramId = ctx.from?.id;
        if (!telegramId) {
          await ctx.reply('–û—à–∏–±–∫–∞: Telegram ID –Ω–µ –Ω–∞–π–¥–µ–Ω.');
          return;
        }
        const client = await processClient(payload, telegramId, botConfig.id, {
          first_name: ctx.from?.first_name,
          last_name: ctx.from?.last_name,
          username: ctx.from?.username,
        });
        ctx.session.isBanned = client.isBanned;
        if (!client.isBanned) {
          const layoutAlias = client.total_visit === 1
            ? botConfig.interface.defaultFirstVisitLayout
            : botConfig.interface.defaultStartLayout;
          log('info', `–í—ã–±—Ä–∞–Ω layoutAlias: ${layoutAlias} (client.total_visit=${client.total_visit})`, payload);
          if (layoutAlias) {
            const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === layoutAlias);
            if (layoutBlock) {
              ctx.session.previousState = layoutBlock;
              await sendLayoutBlock(ctx, botConfig, payload, layoutAlias);
            } else {
              await ctx.reply(`–û—à–∏–±–∫–∞: –õ–µ–π–∞—É—Ç —Å alias "${layoutAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
            }
          } else {
            await ctx.reply('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å layout alias.');
          }
        } else {
          await ctx.reply('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.');
        }
        ctx.session.botConfig = botConfig; // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞ –≤ —Å–µ—Å—Å–∏–∏
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /start: ${error.message}`, payload);
      }
    });

    bot.on('callback_query:data', async (ctx) => {
      if (!ctx.callbackQuery || !ctx.callbackQuery.data) return;
      try {
        const data = ctx.callbackQuery.data;
        const parts = data.split('|');
        const cbType = parts[0]?.trim() ?? '';
        const callbackAlias = parts[1]?.trim() ?? '';

        if (cbType === 'layout' && callbackAlias === 'go_back_state') {
          await goBackState(ctx, payload, botConfig);
        } else if (cbType === 'catalogCategory' || cbType === 'catalogLoadMore') {
          await handleCatalogEvent(cbType, callbackAlias, '', ctx, payload);
          log('info', `Callback "${cbType}|${callbackAlias}" –æ–±—Ä–∞–±–æ—Ç–∞–Ω —á–µ—Ä–µ–∑ handleCatalogEvent.`, payload);
        } else {
          switch (cbType) {
            case 'layout': {
              const layoutBlock = botConfig.interface.blocks.find((block: any) => block.alias === callbackAlias);
              if (layoutBlock) {
                ctx.session.previousState = layoutBlock;
                await sendLayoutBlock(ctx, botConfig, payload, callbackAlias);
              } else {
                await ctx.reply(`–û—à–∏–±–∫–∞: –õ–µ–π–∞—É—Ç —Å alias "${callbackAlias}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
              }
              break;
            }
            case 'message': {
              await processMessageBlock(ctx, { text: callbackAlias });
              log('info', `MessageBlock "${callbackAlias}" —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.`, payload);
              break;
            }
            case 'command': {
              if (callbackAlias === 'go_back_state') {
                await goBackState(ctx, payload, botConfig);
              } else {
                await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${callbackAlias}`);
              }
              break;
            }
            default: {
              await ctx.reply(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø callback: ${cbType}`);
            }
          }
        }
        await ctx.answerCallbackQuery();
      } catch (error: any) {
        log('error', `–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback_query: ${error.message}`, payload);
      }
    });

    bot.start();
    log('info', `ü§ñ –ë–æ—Ç "${botConfig.name}" —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.`, payload);

    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: {
        initialization_status: 'Initialized',
        last_initialized: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞ "${botConfig.name}": ${error.message}`, payload);
    await payload.update({
      collection: 'bots',
      id: botConfig.id,
      data: { initialization_status: 'Error' },
    });
  }
}
// Path: src/plugins/TelegramAPI/utils/BotUtils/BotConfig.ts
// Version: 1.4.7-refactored
//
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –û–±–Ω–æ–≤–ª—ë–Ω –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ protectContent.

import type { UnifiedBotConfig, UnifiedBotInterface } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

const defaultInterface: UnifiedBotInterface = {
  blocks: [],
  defaultStartLayout: 'start',
  defaultFirstVisitLayout: 'start_first_visit',
  total_visit: 0,
};

export class BotConfig {
  public id: number;
  public name: string;
  public token: string;
  public description?: string;
  public enabled: string;
  public initialization_status: string;
  public last_initialized?: string;
  public interface: UnifiedBotInterface;
  public protectContent: boolean;

  constructor(data: UnifiedBotConfig) {
    this.id = data.id;
    this.name = data.name;
    this.token = data.token;
    this.description = data.description;
    this.enabled = data.enabled;
    this.initialization_status = data.initialization_status;
    this.last_initialized = data.last_initialized;
    this.interface = {
      blocks: data.interface?.blocks ?? defaultInterface.blocks,
      defaultStartLayout: data.interface?.defaultStartLayout ?? defaultInterface.defaultStartLayout,
      defaultFirstVisitLayout: data.interface?.defaultFirstVisitLayout ?? defaultInterface.defaultFirstVisitLayout,
      total_visit: typeof data.interface?.total_visit === 'number'
        ? data.interface.total_visit
        : defaultInterface.total_visit,
    };
    this.protectContent = (data as any).protectContent ?? false;
  }

  get telegramApiToken(): string {
    return this.token;
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/goBackState.ts
// Version: 1.0.4-goBack_stack
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò—Å–ø–æ–ª—å–∑—É–µ–º stateStack –∏ currentState –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.

import type { Payload } from 'payload';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';
import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import { sendLayoutBlock } from '@/plugins/TelegramAPI/utils/BlockUtils/LayoutBlock/LayoutBlock';
import { clearPreviousMessages } from '@/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages';

export async function goBackState(ctx: BotContext, payload: Payload, botConfig: any): Promise<void> {
  try {
    // –û—á–∏—â–∞–µ–º –≤—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    await clearPreviousMessages(ctx);

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ —Å—Ç–µ–∫–∞, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    let previousState = null;
    if (ctx.session.stateStack && ctx.session.stateStack.length > 0) {
      previousState = ctx.session.stateStack.pop();
    } else if (ctx.session.currentState) {
      // –ï—Å–ª–∏ —Å—Ç–µ–∫ –ø—É—Å—Ç, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–∫ fallback
      previousState = ctx.session.currentState;
    }

    if (!previousState || !previousState.alias) {
      await ctx.reply('–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
      return;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    ctx.session.currentState = previousState;

    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º layout –ø–æ alias –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    await sendLayoutBlock(ctx, botConfig, payload, previousState.alias);
    log('info', '–ö–æ–º–∞–Ω–¥–∞ go_back_state –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–æ–∑–≤—Ä–∞—â—ë–Ω –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.', payload);
  } catch (error: any) {
    log('error', `–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã go_back_state: ${error.message}`, payload);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.');
  }
}
// Path: src/plugins/TelegramAPI/utils/SystemUtils/clearPreviousMessages.ts
// Version: 1.3.6-refactored
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –ò–º–ø–æ—Ä—Ç—ã —Ç–∏–ø–æ–≤ SessionData –∏ BotContext –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –æ–±—â–∏–π —Ñ–∞–π–ª TelegramBlocksTypes.ts.

import { log } from '@/plugins/TelegramAPI/utils/SystemUtils/Logger';
import type { BotContext } from '@/plugins/TelegramAPI/types/TelegramBlocksTypes';

export async function clearPreviousMessages(ctx: BotContext): Promise<void> {
  if (!ctx.chat || !ctx.session || !Array.isArray(ctx.session.previousMessages)) {
    log('debug', '–ö–æ–Ω—Ç–µ–∫—Å—Ç —á–∞—Ç–∞ –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.');
    return;
  }
  const chatId = ctx.chat.id;
  const messageIds = ctx.session.previousMessages;
  try {
    for (const msgId of messageIds) {
      try {
        await ctx.api.editMessageReplyMarkup(chatId, msgId, { reply_markup: undefined });
      } catch (error: any) {}
      try {
        await ctx.api.deleteMessage(chatId, msgId);
      } catch (error: any) {}
    }
  } catch (err: any) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏
  } finally {
    ctx.session.previousMessages = [];
  }
}

export function storeMessageId(ctx: BotContext, messageId: number): void {
  if (!messageId) return;
  if (ctx.session && Array.isArray(ctx.session.previousMessages)) {
    ctx.session.previousMessages.push(messageId);
  }
}
// üìå –ü—É—Ç—å: src/plugins/TelegramAPI/utils/SystemUtils/Logger.ts
// üìå –í–µ—Ä—Å–∏—è: 1.1.0
//
// [CHANGELOG]
// - –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–º–ø–æ—Ä—Ç `Payload` –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
// - –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ `Payload`.
// - –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ –±–ª–æ–∫–µ Payload CMS –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.

import type { Payload } from 'payload';

/**
 * –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {string} level - –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ('info', 'debug', 'error').
 * @param {string} message - –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param {Payload} [payload] - –≠–∫–∑–µ–º–ø–ª—è—Ä Payload CMS –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞.
 * @param {Record<string, any>} [context] - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–±—ä–µ–∫—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞).
 */
export function log(
  level: 'info' | 'debug' | 'error',
  message: string,
  payload?: Payload,
  context?: Record<string, any>
): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

  // –í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
  if (context && Object.keys(context).length > 0) {
    console.log(logMessage, context);
  } else {
    console.log(logMessage);
  }

  // –í—ã–≤–æ–¥ —á–µ—Ä–µ–∑ Payload CMS, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ
  if (payload?.logger && typeof payload.logger[level] === 'function') {
    try {
      payload.logger[level](message, context || {});
    } catch (err: any) {
      console.error(
        `[${timestamp}] [ERROR] –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ Payload CMS: ${err.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`
      );
    }
  }
}
// Path: src/plugins/TelegramAPI/types/TelegramBlocksTypes.ts
// Version: 2.0.3
// –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π –ø–æ–ª–µ–π –∏ —Ç–∏–ø–æ–≤ –≤ –æ–¥–∏–Ω –æ–±—â–∏–π —Ñ–∞–π–ª.
// –î–æ–±–∞–≤–ª–µ–Ω—ã —Å–≤–æ–π—Å—Ç–≤–∞ currentState –∏ botConfig –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å SessionData –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–æ—Ç–∞.

import type { Context, SessionFlavor } from 'grammy';
import type { BotConfig } from '@/plugins/TelegramAPI/utils/BotUtils/BotConfig';

/** ===============================
 * 1. –¢–∏–ø—ã –±–ª–æ–∫–æ–≤ –¥–ª—è Telegram
 * =============================== */

export enum BlockType {
  Layout = 'layout-blocks',
  Catalog = 'catalog-blocks',
  Message = 'message-blocks',
  Button = 'button-blocks',
  Command = 'command-blocks',
}

export interface TelegramLayoutBlock {
  blockType: BlockType.Layout;
  name: string;
  alias: string;
  blocks: TelegramSubBlock[];
  clearPreviousMessages?: boolean;
}

export interface TelegramCatalogBlock {
  blockType: BlockType.Catalog;
  name: string;
  alias: string;
  itemsPerPage?: number;
}

export interface TelegramMessageBlock {
  blockType: BlockType.Message;
  text: string;
}

export interface TelegramButtonBlock {
  blockType: BlockType.Button;
  text: string;
  callbackType: 'link' | 'message' | 'layout' | 'command';
}

export interface TelegramCommandBlock {
  blockType: BlockType.Command;
  command: string;
  responseText: string;
}

export type TelegramSubBlock =
  | TelegramLayoutBlock
  | TelegramCatalogBlock
  | TelegramMessageBlock
  | TelegramButtonBlock
  | TelegramCommandBlock;

/** ====================================
 * 2. –¢–∏–ø—ã –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
 * ==================================== */

export interface FromData {
  first_name?: string;
  last_name?: string;
  username?: string;
}

/** ====================================
 * 3. –¢–∏–ø—ã –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–∞—Ç–∞–ª–æ–≥–∞
 * ==================================== */

export interface RenderOptions {
  page: number;
  itemsPerPage: number;
  displayMode: 'subcategories' | 'products' | 'all';
}

/** ====================================
 * 4. –¢–∏–ø—ã –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–æ—Ç–∞
 * ==================================== */

export interface UnifiedBotInterface {
  blocks: TelegramSubBlock[];
  defaultStartLayout: string;
  defaultFirstVisitLayout: string;
  total_visit: number;
}

export interface UnifiedBotConfig {
  id: number;
  name: string;
  token: string;
  description?: string;
  enabled: string;
  initialization_status: string;
  last_initialized?: string;
  interface?: Partial<UnifiedBotInterface>;
}

/** ====================================
 * 5. –¢–∏–ø—ã –¥–ª—è —Å–µ—Å—Å–∏–∏ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–æ—Ç–∞
 * ==================================== */

export interface SessionData {
  previousMessages: number[];
  stateStack: any[];
  previousState?: any;
  currentState?: TelegramLayoutBlock;
  isBanned: boolean;
  // –•—Ä–∞–Ω–∏—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞, —á—Ç–æ–±—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä protectContent
  botConfig?: BotConfig;
}

export type BotContext = Context & SessionFlavor<SessionData>;